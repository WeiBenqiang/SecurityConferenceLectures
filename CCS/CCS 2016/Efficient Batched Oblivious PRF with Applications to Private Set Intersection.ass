[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Audio File: ../../../视频/正在听译/CCS 2016/Efficient Batched Oblivious PRF with Applications to Private Set Intersection.mp4
Video File: ../../../视频/正在听译/CCS 2016/Efficient Batched Oblivious PRF with Applications to Private Set Intersection.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.750000
Scroll Position: 228
Active Line: 240
Video Position: 37896

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,45,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.90,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:10.01,0:00:11.08,Default,,0,0,0,,大家好
Dialogue: 0,0:00:11.08,0:00:13.66,Default,,0,0,0,,感谢Stefan的介绍
Dialogue: 0,0:00:13.66,0:00:20.64,Default,,0,0,0,,我的名字是Ni 我是俄勒冈州立大学的博士研究生
Dialogue: 0,0:00:20.64,0:00:24.81,Default,,0,0,0,,很高兴能来到这里介绍我们的工作
Dialogue: 0,0:00:24.81,0:00:33.04,Default,,0,0,0,,我们的论文题目是：高效批处理不经意伪随机函数及其在隐私集合求交中的应用
Dialogue: 0,0:00:33.04,0:00:38.14,Default,,0,0,0,,此工作是由我和Kalashnikov、Kumaresan、以及Rosulek共同完成的
Dialogue: 0,0:00:39.61,0:00:47.29,Default,,0,0,0,,在论文中 我们提出了一个高效的隐私集合求交协议
Dialogue: 0,0:00:47.29,0:00:50.94,Default,,0,0,0,,隐私集合求交是密码学中一个非常有趣的问题
Dialogue: 0,0:00:50.94,0:00:56.80,Default,,0,0,0,,我们以一个简单的场景为例 来看看什么是隐私集合求交
Dialogue: 0,0:00:56.80,0:01:01.68,Default,,0,0,0,,例如 幻灯片上有两个参与方：Alice和Bob
Dialogue: 0,0:01:02.08,0:01:05.60,Default,,0,0,0,,每个参与方都有一个集合 这里分别是X和Y
Dialogue: 0,0:01:05.60,0:01:11.92,Default,,0,0,0,,他们想计算两个集合的交集 但不想泄露其它额外的信息
Dialogue: 0,0:01:11.92,0:01:17.88,Default,,0,0,0,,例如 Alice不能知道Bob集合中非交集的元素
Dialogue: 0,0:01:17.88,0:01:22.24,Default,,0,0,0,,Bob也是类似的 他不能知道Alice集合中非交集的元素
Dialogue: 0,0:01:22.24,0:01:25.76,Default,,0,0,0,,这就是隐私集合求交问题的定义
Dialogue: 0,0:01:25.76,0:01:29.74,Default,,0,0,0,,隐私集合求交的应用场景非常广泛
Dialogue: 0,0:01:29.74,0:01:33.04,Default,,0,0,0,,我这里给出的例子是通讯录匹配场景
Dialogue: 0,0:01:33.04,0:01:40.12,Default,,0,0,0,,例如 Alice有一个手机 里面存储着Alice的通讯录 Alice想要使用Skype
Dialogue: 0,0:01:41.37,0:01:47.98,Default,,0,0,0,,另一边 Bob是一个Skype服务器 里面存储着客户数据
Dialogue: 0,0:01:47.98,0:01:54.33,Default,,0,0,0,,现在 Alice希望知道她的哪些朋友使用Skype 她希望使用Skype与朋友们聊天
Dialogue: 0,0:01:54.33,0:01:58.51,Default,,0,0,0,,很明显 两方希望计算集合的交集
Dialogue: 0,0:01:58.51,0:02:06.83,Default,,0,0,0,,然而 Alice不想泄露自己的通讯录 因为这是她的个人信息
Dialogue: 0,0:02:06.83,0:02:14.59,Default,,0,0,0,,Bob也面临类似的问题 他不能泄露自己的客户数据 因为这是客户的隐私
Dialogue: 0,0:02:15.72,0:02:18.22,Default,,0,0,0,,这个场景就需要使用隐私集合求交功能
Dialogue: 0,0:02:19.44,0:02:25.23,Default,,0,0,0,,当考虑隐私集合求交这个问题时 我们可能会提出下述解决方案
Dialogue: 0,0:02:25.23,0:02:30.20,Default,,0,0,0,,Alice拥有集合X Bob拥有集合Y
Dialogue: 0,0:02:30.20,0:02:35.84,Default,,0,0,0,,他们分别对X中的元素求哈希 对Y中的元素求哈希
Dialogue: 0,0:02:35.84,0:02:39.68,Default,,0,0,0,,Bob随后将哈希值发送给Alice
Dialogue: 0,0:02:39.68,0:02:47.20,Default,,0,0,0,,Alice对比两个集合的哈希值 并输出哈希值相等的元素 即交集元素 
Dialogue: 0,0:02:47.20,0:02:53.02,Default,,0,0,0,,这个协议效率非常高 因为协议只涉及到哈希值的计算
Dialogue: 0,0:02:53.02,0:02:57.82,Default,,0,0,0,,协议涉及的通信量也很小
Dialogue: 0,0:02:57.82,0:03:04.65,Default,,0,0,0,,但不幸的是 这个方案是不安全的 因为这个方案会泄露Bob输入集合的隐私
Dialogue: 0,0:03:04.65,0:03:06.11,Default,,0,0,0,,为什么呢？
Dialogue: 0,0:03:06.11,0:03:12.27,Default,,0,0,0,,如果X属于比较小的域 例如X为电话号码 只包含大约10个数字
Dialogue: 0,0:03:12.27,0:03:19.87,Default,,0,0,0,,Alice直接计算上亿个电话号码的哈希值 并将结果与从Bob收到的结果对比
Dialogue: 0,0:03:19.87,0:03:23.31,Default,,0,0,0,,这样 Alice就可以知道Bob的输入了
Dialogue: 0,0:03:23.31,0:03:27.32,Default,,0,0,0,,这也是此协议被称为朴素哈希的根本原因
Dialogue: 0,0:03:27.32,0:03:30.35,Default,,0,0,0,,因此 这是一个不安全的PSI协议
Dialogue: 0,0:03:31.60,0:03:38.92,Default,,0,0,0,,为了解决这个问题 学者们提出了很多PSI协议
Dialogue: 0,0:03:38.92,0:03:47.15,Default,,0,0,0,,当前最先进的PSI协议由Pinkas、Schneider、Segev和Zohner在2015年提出
Dialogue: 0,0:03:48.38,0:03:53.52,Default,,0,0,0,,隐私集合求交场景下的特殊情况为隐私相等性检测
Dialogue: 0,0:03:53.52,0:03:58.17,Default,,0,0,0,,即两个参与方希望知道两个字符串是否相等
Dialogue: 0,0:03:59.15,0:04:08.43,Default,,0,0,0,,他们的PSI协议通过不经意传输扩展实现隐私相等检测
Dialogue: 0,0:04:08.43,0:04:19.52,Default,,0,0,0,,他们还提出了一个高效的哈希技术 可以将隐私相等检测高效转换为隐私集合求交
Dialogue: 0,0:04:19.52,0:04:25.64,Default,,0,0,0,,我们的核心技术贡献是提高隐私相等检测的效率
Dialogue: 0,0:04:25.64,0:04:33.20,Default,,0,0,0,,我们来看看Pinkas、Schneider、Segev、Zohner提出的隐私相等检测协议
Dialogue: 0,0:04:34.00,0:04:38.22,Default,,0,0,0,,Alice拥有x 而Bob拥有y
Dialogue: 0,0:04:38.22,0:04:41.84,Default,,0,0,0,,我们想知道x=y是否成立
Dialogue: 0,0:04:41.84,0:04:48.41,Default,,0,0,0,,幻灯片上给出了一个例子：x=001、y=011
Dialogue: 0,0:04:48.41,0:04:53.61,Default,,0,0,0,,他们协议的核心思想是对x和y进行逐比特对比
Dialogue: 0,0:04:53.61,0:04:55.88,Default,,0,0,0,,如何做到这一点呢？
Dialogue: 0,0:04:55.88,0:05:01.12,Default,,0,0,0,,他们使用了一个安全的黑盒工具 此工具叫不经意传输
Dialogue: 0,0:05:01.12,0:05:07.18,Default,,0,0,0,,Bob分别为0和1随机采样两个κ比特长的字符串
Dialogue: 0,0:05:07.18,0:05:16.57,Default,,0,0,0,,随后 Bob和Alice执行不经意传输协议 Alice的输入是她的第一个比特0
Dialogue: 0,0:05:16.57,0:05:24.88,Default,,0,0,0,,协议执行完毕后 Alice收到她第一个比特0所对应的字符串0
Dialogue: 0,0:05:24.88,0:05:28.89,Default,,0,0,0,,然而 Bob无法得知Alice在不经意传输中的输入是什么
Dialogue: 0,0:05:28.89,0:05:33.07,Default,,0,0,0,,此性质由不经意传输协议的定义所保证
Dialogue: 0,0:05:33.07,0:05:37.32,Default,,0,0,0,,他们继续对第二个比特、第三个比特执行此种操作
Dialogue: 0,0:05:38.40,0:05:45.80,Default,,0,0,0,,现在 Bob从OT协议中取得自己输入所对应的字符串
Dialogue: 0,0:05:45.80,0:05:54.40,Default,,0,0,0,,他的输入比特是011 因此他分别取得0、1、1所对应的三个字符串
Dialogue: 0,0:05:54.40,0:05:58.75,Default,,0,0,0,,他对几个字符串求异或 将结果发送给Alice
Dialogue: 0,0:05:58.75,0:06:06.25,Default,,0,0,0,,Alice也取得OT执行完毕后的结果 即0、0、1所对应的三个字符串
Dialogue: 0,0:06:06.25,0:06:13.74,Default,,0,0,0,,她对几个字符串求异或 并对比Bob发送过来的异或值
Dialogue: 0,0:06:13.74,0:06:16.80,Default,,0,0,0,,这样Alice就知道双方的输入是否相等了
Dialogue: 0,0:06:16.80,0:06:21.53,Default,,0,0,0,,这就是当前PSI协议的隐私相等检测过程
Dialogue: 0,0:06:22.83,0:06:27.88,Default,,0,0,0,,协议执行过程中 双方逐比特对比x和y
Dialogue: 0,0:06:27.88,0:06:36.35,Default,,0,0,0,,而协议的基本思想是将多个2选1-OT协议替换为一个N选1-OT协议
Dialogue: 0,0:06:36.35,0:06:47.63,Default,,0,0,0,,当前PSI协议使用了Kolesnikov和Kumaresan于2013年提出的OT扩展协议
Dialogue: 0,0:06:47.63,0:06:54.94,Default,,0,0,0,,这意味着每轮协议只能同时对比8比特长的x和y 我后面会讲解为什么会这样
Dialogue: 0,0:06:54.94,0:07:00.11,Default,,0,0,0,,因此 他们的PSI协议中N=2^8
Dialogue: 0,0:07:00.11,0:07:07.58,Default,,0,0,0,,这意味着他们协议的OT执行次数依赖于x和y的比特长度
Dialogue: 0,0:07:07.58,0:07:13.45,Default,,0,0,0,,他们的协议还需要通过多个OT实现完整的隐私相等检测
Dialogue: 0,0:07:13.45,0:07:21.48,Default,,0,0,0,,在我们的工作中 我们提出了一个OT扩展协议 此协议中的N可以任意大
Dialogue: 0,0:07:21.48,0:07:26.96,Default,,0,0,0,,在我们的协议中 N可以为无穷大
Dialogue: 0,0:07:26.96,0:07:33.28,Default,,0,0,0,,这样 我们只需要使用一次OT即可实现隐私相等检测过程
Dialogue: 0,0:07:35.18,0:07:39.96,Default,,0,0,0,,这是当前PSI协议的另一个观察结论
Dialogue: 0,0:07:39.96,0:07:50.00,Default,,0,0,0,,我们将此协议看成一个黑盒 如果Alice的输入是x 而Bob的输入是k
Dialogue: 0,0:07:50.00,0:07:54.75,Default,,0,0,0,,这里k包含右侧的6个数据块
Dialogue: 0,0:07:54.75,0:08:03.56,Default,,0,0,0,,在PSI协议执行完毕后 Alice收到字符串0、0、1的异或值
Dialogue: 0,0:08:03.56,0:08:06.14,Default,,0,0,0,,我们可以将此异或值看成F_k(x)
Dialogue: 0,0:08:06.14,0:08:10.38,Default,,0,0,0,,这意味着协议执行完毕后 Alice只能知道x所对应的F_k(x)
Dialogue: 0,0:08:10.38,0:08:19.76,Default,,0,0,0,,而Bob已知全部的6个数据块 因此Bob可以对任意y计算得到F_k(y)
Dialogue: 0,0:08:19.76,0:08:27.90,Default,,0,0,0,,这里一个非常重要的性质是 如果x≠y 则对Alice来说F_k(y)看起来是个随机数
Dialogue: 0,0:08:27.90,0:08:31.00,Default,,0,0,0,,这么看来 此协议本质上就是一个不经意伪随机函数
Dialogue: 0,0:08:31.00,0:08:37.10,Default,,0,0,0,,不经意伪随机函数是Freedman、Ishai、Pinkas和Reingold在2005年提出的概念
Dialogue: 0,0:08:38.67,0:08:48.01,Default,,0,0,0,,进一步 如果Bob将异或值 也就是F_k(y)发送给Alice
Dialogue: 0,0:08:48.01,0:08:54.70,Default,,0,0,0,,则Alice可以简单地比较F_k(x)和F_k(y) 得知这两个值是否相等
Dialogue: 0,0:08:54.70,0:08:57.58,Default,,0,0,0,,这就是隐私相等检测协议的原理
Dialogue: 0,0:08:58.88,0:09:03.76,Default,,0,0,0,,在接下来的讲座中 我会聚焦于OT扩展协议本身
Dialogue: 0,0:09:03.76,0:09:12.36,Default,,0,0,0,,我们将首先介绍原始的2选1-OT扩展协议 再介绍N选1-OT扩展协议
Dialogue: 0,0:09:12.36,0:09:16.54,Default,,0,0,0,,最后介绍我们构造出的∞选1-OT扩展协议
Dialogue: 0,0:09:16.54,0:09:25.64,Default,,0,0,0,,随后 我们会介绍∞选1-OT扩展协议和我们提出的OPRF实例之间的关系
Dialogue: 0,0:09:25.64,0:09:30.09,Default,,0,0,0,,这里的OPRF对原始OPRF的定义进行了弱化
Dialogue: 0,0:09:30.09,0:09:33.12,Default,,0,0,0,,我后面会详细讲解定义具体的弱化点
Dialogue: 0,0:09:34.36,0:09:38.54,Default,,0,0,0,,我们将我们的OPRF应用在PSI上
Dialogue: 0,0:09:38.54,0:09:44.44,Default,,0,0,0,,从而构造了一个半诚实安全的PSI协议 比当前PSI协议的执行效率高3倍
Dialogue: 0,0:09:44.44,0:09:56.51,Default,,0,0,0,,正如我前面所说 当前PSI协议中 OT的执行次数依赖于集合元素的比特长度
Dialogue: 0,0:09:56.51,0:10:01.39,Default,,0,0,0,,我们的协议移除了OT执行次数与集合元素比特长度的依赖关系
Dialogue: 0,0:10:02.97,0:10:06.96,Default,,0,0,0,,我们先来简单介绍Beaver的OT扩展协议
Dialogue: 0,0:10:06.96,0:10:14.38,Default,,0,0,0,,OT扩展协议的基本思想是 可以用少量OT和对称密码学操作构造大量的OT实例
Dialogue: 0,0:10:14.38,0:10:18.91,Default,,0,0,0,,Beaver在数十年前首次提出了这个想法
Dialogue: 0,0:10:20.40,0:10:28.41,Default,,0,0,0,,现在 我要向大家介绍一个非常著名、非常高效的OT扩展协议
Dialogue: 0,0:10:28.41,0:10:34.62,Default,,0,0,0,,此协议由Ishai、Kilian、Nissim和Petrank于2003年提出
Dialogue: 0,0:10:35.79,0:10:43.69,Default,,0,0,0,,此协议的基本思想是 在基础OT协议中 Alice选择一个随机的κ比特长字符串t^1
Dialogue: 0,0:10:43.69,0:10:48.32,Default,,0,0,0,,她计算得到另一个字符串t^1⊕r
Dialogue: 0,0:10:48.32,0:10:54.67,Default,,0,0,0,,在另一端还有个参与方Bob 他有一个单比特字符串s_1
Dialogue: 0,0:10:55.84,0:11:01.34,Default,,0,0,0,,如果s_1=0 则Bob接收到第一列字符串t^1
Dialogue: 0,0:11:01.34,0:11:07.42,Default,,0,0,0,,如果s_1=1 则Bob接收到第二列字符串t^1⊕r
Dialogue: 0,0:11:07.42,0:11:15.21,Default,,0,0,0,,也就是说 Bob可以根据自己的选择比特s_1接收到字符串q_1
Dialogue: 0,0:11:15.21,0:11:22.25,Default,,0,0,0,,OT协议定义的功能就是这样的
Dialogue: 0,0:11:23.47,0:11:31.18,Default,,0,0,0,,现在 他们重复上述过程κ次 每次都使用相同的r
Dialogue: 0,0:11:31.18,0:11:36.68,Default,,0,0,0,,最后 Bob收到包含κ列的矩阵q
Dialogue: 0,0:11:36.68,0:11:41.02,Default,,0,0,0,,每列q_i的值都由比特s_i所决定
Dialogue: 0,0:11:42.70,0:11:53.07,Default,,0,0,0,,现在 他们使用轻量级的密码学技术伪随机数生成器将κ个OT扩展为n个OT
Dialogue: 0,0:11:53.07,0:11:59.10,Default,,0,0,0,,这里n要远远大于κ n大约等于2^20
Dialogue: 0,0:12:00.56,0:12:05.18,Default,,0,0,0,,在整个协议执行过程中 Alice得到了矩阵T和矩阵T⊕r
Dialogue: 0,0:12:05.18,0:12:07.82,Default,,0,0,0,,我们将这组矩阵称为OT矩阵
Dialogue: 0,0:12:08.88,0:12:18.20,Default,,0,0,0,,如果我们从行的角度观察这个矩阵 并且令t_i表示第一个矩阵的第i行
Dialogue: 0,0:12:18.20,0:12:29.98,Default,,0,0,0,,如果令r_i表示r的第i个比特值 则第二个矩阵的第i行就等于t_i 则此时q_i=t_i
Dialogue: 0,0:12:29.98,0:12:32.62,Default,,0,0,0,,左右两行下标相同 取值也相同
Dialogue: 0,0:12:34.03,0:12:43.18,Default,,0,0,0,,如果r_i=1 则第二个矩阵的第i行等于t_i⊕1^κ 此时q_i=t_i⊕s
Dialogue: 0,0:12:43.18,0:12:47.77,Default,,0,0,0,,也就是说 r_i或者等于0 或者等于1 长度为1比特
Dialogue: 0,0:12:47.77,0:12:53.77,Default,,0,0,0,,而q_i=t_i⊕(r_i)^κ⊙s
Dialogue: 0,0:12:55.18,0:13:00.80,Default,,0,0,0,,现在 我们把目标聚焦于OT矩阵本身
Dialogue: 0,0:13:00.80,0:13:12.43,Default,,0,0,0,,如果Alice的输入是r_i Bob的输入是s 则Alice已知t_i 她可以计算t_i的哈希值
Dialogue: 0,0:13:12.43,0:13:20.25,Default,,0,0,0,,Bob收到q_i后 可以计算q_i的哈希值 以及q_i⊕s的哈希值
Dialogue: 0,0:13:20.25,0:13:31.12,Default,,0,0,0,,这里一个非常重要的性质是 t_i=q_i 或者t_i=q_i⊕s 具体等于什么取决于r_i
Dialogue: 0,0:13:32.56,0:13:38.41,Default,,0,0,0,,也就是说 H(q_i)和H(q_i⊕s)有且仅有一个值等于H(t_i)
Dialogue: 0,0:13:38.41,0:13:41.88,Default,,0,0,0,,而另一个值对Alice来说看起来像随机数
Dialogue: 0,0:13:41.88,0:13:45.47,Default,,0,0,0,,换句话说 Bob有两个值 Alice只知道其中的一个值
Dialogue: 0,0:13:47.00,0:13:57.21,Default,,0,0,0,,在2013年 Kolesnikov和Kumaresan指出 IKNP协议中包含重复编码
Dialogue: 0,0:13:57.21,0:14:07.85,Default,,0,0,0,,如果称C是一个κ个比特值重复编码κ次的编码过程 我们再来研究一下IKNP协议
Dialogue: 0,0:14:07.85,0:14:11.72,Default,,0,0,0,,第二个矩阵的第i行等于t_i⊕C(r_i)
Dialogue: 0,0:14:11.72,0:14:20.14,Default,,0,0,0,,而q_i等于t_i⊕C(r_i)⊙s
Dialogue: 0,0:14:20.14,0:14:22.86,Default,,0,0,0,,Bob计算的是幻灯片上这两个值的哈希值
Dialogue: 0,0:14:22.86,0:14:32.72,Default,,0,0,0,,现在 如果把随机编码移除 将C替换为纠错编码
Dialogue: 0,0:14:32.72,0:14:41.05,Default,,0,0,0,,则此协议可以支持长度最大为8比特的选择比特值r_i
Dialogue: 0,0:14:41.05,0:14:52.14,Default,,0,0,0,,这也是为什么当前PSI协议只能对比8比特长的x和8比特长的y
Dialogue: 0,0:14:52.14,0:14:58.44,Default,,0,0,0,,举例来说 我们令C的输入为3比特长
Dialogue: 0,0:14:59.77,0:15:09.44,Default,,0,0,0,,此时Bob需要根据幻灯片上的公式计算8个哈希值
Dialogue: 0,0:15:09.44,0:15:24.56,Default,,0,0,0,,我们得到了一个非常重要的性质：H(q_i⊕C(r')⊙s)=H(t_i⊕[C(r')⊕C(r_i)]⊙s)
Dialogue: 0,0:15:25.90,0:15:30.35,Default,,0,0,0,,现在 我们观察等式中的绿色部分
Dialogue: 0,0:15:30.35,0:15:37.24,Default,,0,0,0,,如果r_i=r' 则绿色部分等于0
Dialogue: 0,0:15:37.24,0:15:41.60,Default,,0,0,0,,绿色部分与s逐比特与 计算结果还是0
Dialogue: 0,0:15:41.60,0:15:44.76,Default,,0,0,0,,这意味着我们得到的是H(t_i)
Dialogue: 0,0:15:44.76,0:15:52.30,Default,,0,0,0,,换句话说 Bob可以计算m个哈希值 而Alice只能得到其中一个哈希值
Dialogue: 0,0:15:52.30,0:15:56.68,Default,,0,0,0,,这也是为什么此协议被称为N选1-OT的原因
Dialogue: 0,0:15:57.96,0:16:06.01,Default,,0,0,0,,从安全角度看 他们的协议要求C(r’)⊕C(r_i)的汉明重量要大于κ
Dialogue: 0,0:16:06.01,0:16:10.60,Default,,0,0,0,,我们翻到下一页幻灯片 讲解其中的原因
Dialogue: 0,0:16:10.60,0:16:13.24,Default,,0,0,0,,Bob能得到什么？
Dialogue: 0,0:16:13.24,0:16:17.90,Default,,0,0,0,,他计算得到H(q_i⊕C(r')⊙s)
Dialogue: 0,0:16:17.90,0:16:24.59,Default,,0,0,0,,这个值等于H(t_i⊕[C(r')⊕C(r_i)]⊙s)
Dialogue: 0,0:16:25.74,0:16:34.22,Default,,0,0,0,,如果r_i≠r' 则此表达式计算得到的值对Alice来说是个随机数
Dialogue: 0,0:16:35.63,0:16:41.34,Default,,0,0,0,,然而 如果Alice可以通过某种方式猜测r'的值
Dialogue: 0,0:16:41.34,0:16:47.98,Default,,0,0,0,,如果Alice知道了r' 她就知道了t_i 她也就知道了r_i
Dialogue: 0,0:16:47.98,0:16:54.09,Default,,0,0,0,,这实际上意味着Alice知道此表达式所有红色部分的取值 但不知道蓝色部分s的值
Dialogue: 0,0:16:55.40,0:17:05.26,Default,,0,0,0,,如果C的最小汉明距离为κ 则C(r')⊕C(r_i)的汉明重量大于κ
Dialogue: 0,0:17:06.41,0:17:09.92,Default,,0,0,0,,这意味着Alice必须正确猜测s中的κ个比特
Dialogue: 0,0:17:09.92,0:17:15.80,Default,,0,0,0,,这样一来 此协议就满足安全性要求了
Dialogue: 0,0:17:17.60,0:17:20.24,Default,,0,0,0,,下面是我们的观察结论
Dialogue: 0,0:17:20.24,0:17:24.65,Default,,0,0,0,,我们发现 我们不需要使用编码算法
Dialogue: 0,0:17:24.65,0:17:29.58,Default,,0,0,0,,我们将C替换为输出κ比特长随机字符串的随机函数
Dialogue: 0,0:17:29.58,0:17:35.58,Default,,0,0,0,,这是一个非常小的技巧 但这个技巧让我们的协议变得非常厉害
Dialogue: 0,0:17:35.58,0:17:46.62,Default,,0,0,0,,如果我们将C替换为随机函数 则我们的协议可以支持任意长度的r_i
Dialogue: 0,0:17:46.62,0:17:49.37,Default,,0,0,0,,也就是说 这里的r_i可以为任意比特长
Dialogue: 0,0:17:50.36,0:18:00.30,Default,,0,0,0,,从Bob的角度看 他可以计算得到H(q_i⊕C(r')⊙s)
Dialogue: 0,0:18:00.30,0:18:07.53,Default,,0,0,0,,这意味着从正确性角度看 我们所得到的协议与之前的协议功能完全相同
Dialogue: 0,0:18:07.53,0:18:13.77,Default,,0,0,0,,在我们的协议中 Bob可以计算任意哈希值 而Alice只能知道其中一个哈希值
Dialogue: 0,0:18:13.77,0:18:18.65,Default,,0,0,0,,这就是为什么我们称我们的协议是∞选1-OT扩展的原因
Dialogue: 0,0:18:20.33,0:18:28.91,Default,,0,0,0,,从安全性看 我们要计算C的最优输出比特长度 让此长度等于λ 从而得到安全性
Dialogue: 0,0:18:30.46,0:18:38.17,Default,,0,0,0,,从前面两页幻灯片中 我们可以得到幻灯片上的这一行结论
Dialogue: 0,0:18:38.17,0:18:42.70,Default,,0,0,0,,现在 我们将C设置成了伪随机函数
Dialogue: 0,0:18:42.70,0:18:56.03,Default,,0,0,0,,从安全性角度看 我们只需让C(r')⊕C(r_i)的最小汉明重量是可忽略函数即可
Dialogue: 0,0:18:56.03,0:19:03.34,Default,,0,0,0,,为此 我们让伪随机函数C的输出比特长度为3.5κ
Dialogue: 0,0:19:07.39,0:19:13.29,Default,,0,0,0,,这就是为满足协议的安全性 我们需要设置的算法参数
Dialogue: 0,0:19:13.29,0:19:20.06,Default,,0,0,0,,这也意味着我们需要把基础OT矩阵宽度扩展到3.5κ比特
Dialogue: 0,0:19:20.06,0:19:26.04,Default,,0,0,0,,不过 我们没必要使用更多的基础OT来扩展OT矩阵宽度
Dialogue: 0,0:19:26.04,0:19:36.83,Default,,0,0,0,,我们使用了一个小技巧 应用伪随机数生成器将OT矩阵的高度扩展到3.5κ比特
Dialogue: 0,0:19:36.83,0:19:45.26,Default,,0,0,0,,随后 我们对矩阵转置 得到宽度为3.5κ比特的基础OT矩阵
Dialogue: 0,0:19:45.26,0:19:51.24,Default,,0,0,0,,这样 我们的协议就满足了安全性要求
Dialogue: 0,0:19:53.16,0:19:56.12,Default,,0,0,0,,这是协议的完整执行流程
Dialogue: 0,0:19:56.12,0:20:07.56,Default,,0,0,0,,再次强调 如果r_i≠r' 则F_(s,q_i)(r')看起来像是随机数
Dialogue: 0,0:20:07.56,0:20:15.05,Default,,0,0,0,,而F_(s,q_i)(r)=H(q_i⊕C(r)⊙s)
Dialogue: 0,0:20:16.48,0:20:20.68,Default,,0,0,0,,这就是不经意伪随机函数F_(s,q_i)(r)的定义
Dialogue: 0,0:20:21.88,0:20:32.36,Default,,0,0,0,,OT矩阵的每一行都定义了一个OPRF实例
Dialogue: 0,0:20:32.36,0:20:36.48,Default,,0,0,0,,这也是为什么我们将我们的协议命名为批处理OPRF的原因
Dialogue: 0,0:20:37.72,0:20:44.14,Default,,0,0,0,,每一行对应的第二个密钥q_i均不相同 但第一个密钥s是相同的
Dialogue: 0,0:20:44.14,0:20:48.84,Default,,0,0,0,,因此 我们得到的是批处理密钥相关OPRF
Dialogue: 0,0:20:48.84,0:20:52.86,Default,,0,0,0,,这也是为什么我们将我们的协议最终命名为批处理密钥相关OPRF的原因
Dialogue: 0,0:20:54.11,0:20:59.28,Default,,0,0,0,,很容易在PSI上应用此OPRF
Dialogue: 0,0:20:59.28,0:21:03.56,Default,,0,0,0,,Bob将F_(s,q_i)(r')发送给Alice
Dialogue: 0,0:21:03.56,0:21:11.05,Default,,0,0,0,,Alice简单比较F_(s,q_i)(r_i)和F_(s,q_i)(r') 并告知这两个值是否相等
Dialogue: 0,0:21:11.05,0:21:17.05,Default,,0,0,0,,如果r_i≠r' 则对Alice来说F_(s,q_i)(r')像是个随机数
Dialogue: 0,0:21:17.05,0:21:21.82,Default,,0,0,0,,这意味着Alice无法猜测得到有关r'的任何信息
Dialogue: 0,0:21:21.82,0:21:24.78,Default,,0,0,0,,这就是隐私相等检测协议的执行过程
Dialogue: 0,0:21:26.33,0:21:37.05,Default,,0,0,0,,最终 我们协议的OT执行次数不依赖于输入比特长度|r'|、也不依赖于|r_i|
Dialogue: 0,0:21:37.05,0:21:41.37,Default,,0,0,0,,我们的协议比当前PSI协议执行效率快3倍
Dialogue: 0,0:21:42.88,0:21:49.37,Default,,0,0,0,,幻灯片上给出了半诚实PSI协议的执行效率对比
Dialogue: 0,0:21:49.37,0:21:57.02,Default,,0,0,0,,基于电路的PSI协议的意思是使用通用安全计算协议实现PSI
Dialogue: 0,0:21:57.02,0:21:59.60,Default,,0,0,0,,此类协议的执行效率较低
Dialogue: 0,0:21:59.60,0:22:09.16,Default,,0,0,0,,如果我们使用公钥密码学构造PSI协议 协议的通信效率很高 但计算效率较低
Dialogue: 0,0:22:09.16,0:22:19.13,Default,,0,0,0,,基于OT构造PSI的协议效率较高 计算复杂度和通信复杂度都比较低
Dialogue: 0,0:22:20.14,0:22:28.67,Default,,0,0,0,,我们也对比了最近提出的两个协议 我们的协议比当前PSI协议执行效率快3倍
Dialogue: 0,0:22:28.67,0:22:33.12,Default,,0,0,0,,X轴用10为底的对数进行了放缩
Dialogue: 0,0:22:33.12,0:22:38.49,Default,,0,0,0,,我们协议的执行效率进一步向朴素哈希算法的执行效率迈进
Dialogue: 0,0:22:39.48,0:22:42.46,Default,,0,0,0,,感谢大家的聆听
Dialogue: 0,0:22:42.46,0:22:43.47,Default,,0,0,0,,感谢主讲人的演讲
Dialogue: 0,0:22:48.68,0:22:51.24,Default,,0,0,0,,我们还有一些提问的时间
Dialogue: 0,0:22:56.94,0:22:58.96,Default,,0,0,0,,你好 有个地方我没有想明白
Dialogue: 0,0:22:58.96,0:23:08.22,Default,,0,0,0,,如果我们用盲签名等公钥密码学方案构建OPRF 
Dialogue: 0,0:23:08.22,0:23:15.08,Default,,0,0,0,,则此类方案只需要一轮交互 但你提到公钥密码学方案的执行效率很低
Dialogue: 0,0:23:17.45,0:23:19.60,Default,,0,0,0,,你能再描述一遍问题吗？
Dialogue: 0,0:23:19.60,0:23:26.78,Default,,0,0,0,,应用OPRF实现PSI的最直接方法是
Dialogue: 0,0:23:26.78,0:23:32.44,Default,,0,0,0,,Alice要求Bob对双方的字符串签名
Dialogue: 0,0:23:32.44,0:23:34.80,Default,,0,0,0,,Bob对字符串签名 并将结果返回给Alice
Dialogue: 0,0:23:34.80,0:23:36.59,Default,,0,0,0,,Alice检查签名结果是否相等
Dialogue: 0,0:23:36.59,0:23:39.79,Default,,0,0,0,,只要签名结果是唯一的 这个协议就是正确的
Dialogue: 0,0:23:41.16,0:23:44.36,Default,,0,0,0,,当然这里还有很多限制条件 比如不能直接使用RSA 但是…
Dialogue: 0,0:23:46.65,0:23:51.02,Default,,0,0,0,,这个方案效率很高 可以实现PSI
Dialogue: 0,0:23:51.02,0:23:54.88,Default,,0,0,0,,你前面提到 参与方A要对参与方B所有的字符串签名
Dialogue: 0,0:23:54.88,0:23:55.23,Default,,0,0,0,,是的
Dialogue: 0,0:23:55.23,0:24:00.33,Default,,0,0,0,,参与方A同时要对它自己的字符串签名 随后取两组签名的交集
Dialogue: 0,0:24:00.33,0:24:02.99,Default,,0,0,0,,但你前面提到这个过程效率很低 因为…
Dialogue: 0,0:24:02.99,0:24:06.25,Default,,0,0,0,,我明白了 感谢你提出的问题
Dialogue: 0,0:24:06.25,0:24:16.56,Default,,0,0,0,,我们的OPRF只需要使用少量的公钥密码学方案 但需要使用大量的对称密码学方案
Dialogue: 0,0:24:16.56,0:24:21.08,Default,,0,0,0,,这就是我们的协议要比公钥密码学方案的协议高效的原因
Dialogue: 0,0:24:22.88,0:24:26.49,Default,,0,0,0,,因为你只需要执行128次公钥密码学操作吗？
Dialogue: 0,0:24:26.49,0:24:30.28,Default,,0,0,0,,是的 我们只需要执行128次 你可以看这页幻灯片
Dialogue: 0,0:24:32.89,0:24:35.87,Default,,0,0,0,,这里的技巧在于… 稍等一下
Dialogue: 0,0:24:37.74,0:24:45.42,Default,,0,0,0,,我们在OPRF协议中使用了OT扩展协议
Dialogue: 0,0:24:45.42,0:24:53.69,Default,,0,0,0,,这意味着我们只需要执行128次公钥密码学操作 或者说κ次公钥密码学操作
Dialogue: 0,0:24:53.69,0:24:54.14,Default,,0,0,0,,明白了
Dialogue: 0,0:24:54.33,0:24:56.43,Default,,0,0,0,,是的 我们还使用了对称密码学
Dialogue: 0,0:24:56.43,0:25:01.68,Default,,0,0,0,,很显然 对称密码学的执行效率比公钥密码学高得多 所以…
Dialogue: 0,0:25:02.92,0:25:03.58,Default,,0,0,0,,明白了
Dialogue: 0,0:25:03.58,0:25:04.72,Default,,0,0,0,,好的 谢谢
Dialogue: 0,0:25:04.72,0:25:09.31,Default,,0,0,0,,所以这个方案才能这样高效地完成计算 明白了
Dialogue: 0,0:25:09.31,0:25:10.16,Default,,0,0,0,,是的 谢谢
Dialogue: 0,0:25:11.88,0:25:15.50,Default,,0,0,0,,听众还有什么其它问题吗？
Dialogue: 0,0:25:15.84,0:25:19.42,Default,,0,0,0,,没有其它问题了 我们再次感谢主讲人
Dialogue: 0,0:25:20.23,0:25:23.12,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
