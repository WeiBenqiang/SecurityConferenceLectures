[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ObliVM A Programming Framework for Secure Computation.mp4
Video File: ObliVM A Programming Framework for Secure Computation.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 179
Active Line: 204
Video Position: 37554

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Microsoft YaHei,45,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.99999,1.99999,2,10,10,11,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,49.999)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:00.65,0:00:01.63,Default,,0,0,0,,大家好
Dialogue: 0,0:00:01.63,0:00:06.97,Default,,0,0,0,,我很高兴能在这里为大家介绍我们的工作：ObliVM
Dialogue: 0,0:00:06.97,0:00:10.43,Default,,0,0,0,,这是一个安全计算的编程框架
Dialogue: 0,0:00:10.43,0:00:13.81,Default,,0,0,0,,这是我和我的队友们一同完成的工作
Dialogue: 0,0:00:13.81,0:00:18.06,Default,,0,0,0,,队友有Xiao Wang 坐在那里的Kartik 还有Yan Huang 还有Elaine Shi
Dialogue: 0,0:00:19.07,0:00:28.97,Default,,0,0,0,,很高兴自己在前面的一个演讲中为大家充分介绍了什么是安全计算 或安全函数求值
Dialogue: 0,0:00:28.97,0:00:32.68,Default,,0,0,0,,我这里只需给出一个简短的介绍
Dialogue: 0,0:00:32.68,0:00:39.13,Default,,0,0,0,,例如 Sheldon和Amy希望互相确认自己是不是对方的另一半
Dialogue: 0,0:00:39.13,0:00:41.89,Default,,0,0,0,,他们都相信基因匹配的效果
Dialogue: 0,0:00:41.89,0:00:48.92,Default,,0,0,0,,因此 他们可以执行一个分析过程 看看他们是否匹配
Dialogue: 0,0:00:48.92,0:00:55.49,Default,,0,0,0,,一个很关键的安全问题是 他们不想把敏感的基因数据泄露给对方
Dialogue: 0,0:00:55.49,0:01:05.30,Default,,0,0,0,,我在前面已经讲过了 安全计算是这一问题的绝佳解决方案
Dialogue: 0,0:01:05.30,0:01:10.40,Default,,0,0,0,,我们可以把这个问题抽象成下述形式
Dialogue: 0,0:01:10.40,0:01:16.10,Default,,0,0,0,,给定两个参与方Alice和Bob 以及他们的秘密输入x和y
Dialogue: 0,0:01:16.10,0:01:22.08,Default,,0,0,0,,他们希望联合计算一个公开函数f(x,y) 得到函数的计算结果
Dialogue: 0,0:01:22.08,0:01:30.74,Default,,0,0,0,,同时 除了计算结果z外 涉及两个秘密输入的计算过程不会向对方泄露任何其它信息
Dialogue: 0,0:01:30.74,0:01:32.57,Default,,0,0,0,,这就是安全计算的概念
Dialogue: 0,0:01:32.57,0:01:43.57,Default,,0,0,0,,大家已经知道 安全计算的解决方案有姚氏乱码电路 还有GMW协议
Dialogue: 0,0:01:43.57,0:01:46.75,Default,,0,0,0,,我们关注什么地方呢？
Dialogue: 0,0:01:46.75,0:01:51.42,Default,,0,0,0,,我们的关注点是 如何让安全计算能在实际中得到应用？
Dialogue: 0,0:01:51.42,0:01:56.54,Default,,0,0,0,,例如 一个开发者希望开发一个安全计算应用
Dialogue: 0,0:01:56.54,0:01:59.17,Default,,0,0,0,,他们肯定不想把函数写成电路的形式
Dialogue: 0,0:01:59.17,0:02:04.56,Default,,0,0,0,,他们想用C语言、Java语言、或者Python语言编写代码
Dialogue: 0,0:02:04.56,0:02:11.58,Default,,0,0,0,,因此 源程序和安全计算协议之间存在很大的鸿沟
Dialogue: 0,0:02:11.58,0:02:14.69,Default,,0,0,0,,这就是我们ObliVM框架要做的事情
Dialogue: 0,0:02:14.69,0:02:27.89,Default,,0,0,0,,我们的ObliVM是一个工具 可以将源代码转换成实际的安全计算协议
Dialogue: 0,0:02:27.89,0:02:29.46,Default,,0,0,0,,这是ObliVM的框架概览
Dialogue: 0,0:02:29.46,0:02:32.24,Default,,0,0,0,,这里面最主要的问题是什么？
Dialogue: 0,0:02:32.24,0:02:43.22,Default,,0,0,0,,Kartik已经提到 主要问题是开发人员喜欢用Python等语言模型编写代码
Dialogue: 0,0:02:43.22,0:02:47.21,Default,,0,0,0,,幻灯片左侧是开发人员撰写的源程序
Dialogue: 0,0:02:47.21,0:02:54.06,Default,,0,0,0,,但实际上 大多数安全计算协议是在电路模型下实现的
Dialogue: 0,0:02:54.06,0:03:00.74,Default,,0,0,0,,因此 在高层语言程序和电路程序之间存在很大的鸿沟
Dialogue: 0,0:03:00.74,0:03:06.83,Default,,0,0,0,,我们的问题是 如何将左侧的代码转换为右侧的协议？
Dialogue: 0,0:03:08.76,0:03:14.45,Default,,0,0,0,,非常感谢Kartik的讲解 你已经提出了我们工作的出发点
Dialogue: 0,0:03:14.45,0:03:21.40,Default,,0,0,0,,这里的关键挑战是 如何能让动态内存访问过程不泄露信息
Dialogue: 0,0:03:21.40,0:03:29.30,Default,,0,0,0,,这是一个不太容易解决的挑战
Dialogue: 0,0:03:29.30,0:03:44.42,Default,,0,0,0,,我们的解决方案是 把RAM模型下的问题转换到不经意RAM模型中
Dialogue: 0,0:03:44.42,0:03:52.84,Default,,0,0,0,,不经意的意思是内存访问和指令追踪过程不依赖于秘密输入
Dialogue: 0,0:03:52.84,0:04:00.22,Default,,0,0,0,,这样一来 不经意程序就可以被进一步转换为电路了
Dialogue: 0,0:04:00.22,0:04:08.27,Default,,0,0,0,,我们可以看到 在转换链路中 后一部分相对比较简单 前一部分非常有挑战性
Dialogue: 0,0:04:08.27,0:04:13.47,Default,,0,0,0,,本次讲座主要关注前一部分 解释如何做到这一点
Dialogue: 0,0:04:15.24,0:04:21.76,Default,,0,0,0,,有一个非常平凡 也不能说非常平凡的解决方案
Dialogue: 0,0:04:21.76,0:04:27.10,Default,,0,0,0,,这个方案于2013年首先提出 基本思想是使用不经意RAM
Dialogue: 0,0:04:27.10,0:04:34.78,Default,,0,0,0,,不经意RAM 又称ORAM 可以把任意程序编译成不经意程序
Dialogue: 0,0:04:34.78,0:04:46.32,Default,,0,0,0,,基于这一思想 我们去年提出了SCVAM框架 此框架可以仿真通用ORAM
Dialogue: 0,0:04:47.55,0:04:55.10,Default,,0,0,0,,可以证明 我们的渐进性能比所有之前的解决方案都要好
Dialogue: 0,0:04:56.20,0:05:01.77,Default,,0,0,0,,这一解决方案是通用的 也很容易实现
Dialogue: 0,0:05:01.77,0:05:06.44,Default,,0,0,0,,但问题在于 这个方案可能不是最高效的
Dialogue: 0,0:05:06.44,0:05:12.33,Default,,0,0,0,,在过去的几年间 我们观察到研究人员提出了很多定制化安全计算协议
Dialogue: 0,0:05:12.33,0:05:19.07,Default,,0,0,0,,这方面的工作有很多 我实在没办法在幻灯片上把所有相关工作都列出来
Dialogue: 0,0:05:19.07,0:05:22.12,Default,,0,0,0,,这些定制化安全计算协议都很高效
Dialogue: 0,0:05:22.12,0:05:28.99,Default,,0,0,0,,可以这么说 这些协议比我们去年的工作都高效
Dialogue: 0,0:05:28.99,0:05:33.42,Default,,0,0,0,,但问题在于 这些协议的设计成本很高
Dialogue: 0,0:05:33.42,0:05:39.37,Default,,0,0,0,,例如 我们与Nina Taft聊了聊 她是我们的合作方
Dialogue: 0,0:05:39.37,0:05:49.87,Default,,0,0,0,,我们私下针对CCS 2013上面发表的隐私矩阵分解算法进行了讨论
Dialogue: 0,0:05:49.87,0:05:58.75,Default,,0,0,0,,她告诉我们 她们组织了5位研究人员 花费了大约4个月的时间才完成了全部的实现
Dialogue: 0,0:05:58.75,0:06:05.13,Default,,0,0,0,,也就是说 整个过程花费了超过1.5年的研究时间
Dialogue: 0,0:06:05.13,0:06:08.06,Default,,0,0,0,,这里涉及到巨大的工作量
Dialogue: 0,0:06:09.36,0:06:13.07,Default,,0,0,0,,我们的问题是：我们能不能做得更好？
Dialogue: 0,0:06:13.07,0:06:20.92,Default,,0,0,0,,我们能否构建一个通用框架 但仍然获得定制化协议的执行效率？
Dialogue: 0,0:06:20.92,0:06:26.52,Default,,0,0,0,,这就是我们ObliVM的目标
Dialogue: 0,0:06:26.52,0:06:32.03,Default,,0,0,0,,我们希望非领域专家 例如非密码学家
Dialogue: 0,0:06:32.03,0:06:38.01,Default,,0,0,0,,可以用它实现一些安全计算协议 同时获得定制化协议的执行效率
Dialogue: 0,0:06:38.91,0:06:41.29,Default,,0,0,0,,我们如何做到这一点？
Dialogue: 0,0:06:41.29,0:06:49.71,Default,,0,0,0,,关键思想是：在ObliVM内部 我们提供很多编程抽象接口
Dialogue: 0,0:06:49.71,0:06:55.26,Default,,0,0,0,,我在幻灯片上具体列举了一些 如不经意数据结构、MapReduce、循环合并等
Dialogue: 0,0:06:55.26,0:06:57.60,Default,,0,0,0,,我后面会介绍其中一个抽象接口
Dialogue: 0,0:06:57.60,0:07:02.38,Default,,0,0,0,,如果想了解更多的细节 请阅读我们的论文
Dialogue: 0,0:07:02.38,0:07:16.92,Default,,0,0,0,,我还想提及的是 Kartik刚刚讲解的GraphSC论文也是一个并行计算编程接口抽象
Dialogue: 0,0:07:18.16,0:07:24.00,Default,,0,0,0,,总之 我们提供了一些编程接口抽象
Dialogue: 0,0:07:24.00,0:07:28.80,Default,,0,0,0,,我这里想简单介绍一下编程接口抽象到底是什么
Dialogue: 0,0:07:28.80,0:07:31.82,Default,,0,0,0,,我们来看看分布式计算社区
Dialogue: 0,0:07:31.82,0:07:37.45,Default,,0,0,0,,我估计绝大多数人都听说过MapReduce 
Dialogue: 0,0:07:37.45,0:07:43.29,Default,,0,0,0,,这是谷歌于2004年在OSDI会议上发表的论文
Dialogue: 0,0:07:43.29,0:07:52.83,Default,,0,0,0,,在这篇论文发表之前 并行计算 或者说分布式计算 是一个很困难的任务
Dialogue: 0,0:07:52.83,0:08:02.75,Default,,0,0,0,,但通过MapReduce 开发者只需要将计算过程编码在Mapper和Reducer框架中
Dialogue: 0,0:08:02.75,0:08:11.93,Default,,0,0,0,,开发者不需要关注分布式计算方法 MapReduce框架会实现整个分布式计算过程
Dialogue: 0,0:08:11.93,0:08:19.69,Default,,0,0,0,,因此 与之前的工作相比 使用MapReduce涉及的开发工作量会非常小
Dialogue: 0,0:08:19.69,0:08:26.00,Default,,0,0,0,,我们想用与之非常类似的方法解决这一问题
Dialogue: 0,0:08:26.00,0:08:38.14,Default,,0,0,0,,我们希望提供一些抽象接口 允许开发者将计算任务编码在抽象接口中
Dialogue: 0,0:08:38.14,0:08:48.51,Default,,0,0,0,,这样他们就不需要关注底层的密码学原语 但仍然获得相同的计算性能
Dialogue: 0,0:08:51.24,0:08:56.54,Default,,0,0,0,,这就是我们的目标 这就是我们的解决方案
Dialogue: 0,0:08:56.54,0:09:00.25,Default,,0,0,0,,我们如何对外提供这些编程接口抽象？
Dialogue: 0,0:09:00.25,0:09:04.68,Default,,0,0,0,,我们希望实现一个新的语言支持体系
Dialogue: 0,0:09:04.68,0:09:10.80,Default,,0,0,0,,例如 我们想为我们的开发者实现一个新的编程语言
Dialogue: 0,0:09:10.80,0:09:17.07,Default,,0,0,0,,在开发这个语言时 我们脑海中有两个目标
Dialogue: 0,0:09:17.07,0:09:29.29,Default,,0,0,0,,第一个目标是：领域专家或密码学家可以很容易地应用此语言实现不同的编程接口
Dialogue: 0,0:09:29.29,0:09:38.80,Default,,0,0,0,,另一方面 对于非专家来说 他们可能不是特别了解密码学技术
Dialogue: 0,0:09:38.80,0:09:44.09,Default,,0,0,0,,他们可以很容易地使用这些编程语言抽象构建他们自己的应用程序
Dialogue: 0,0:09:45.71,0:09:54.44,Default,,0,0,0,,结合脑海中的这两个目标 我们的解决方案是构建新的语言特性
Dialogue: 0,0:09:54.44,0:09:58.24,Default,,0,0,0,,支持之前系统未无法支持的功能
Dialogue: 0,0:09:58.24,0:10:05.32,Default,,0,0,0,,我这里列举了一些特性 请大家阅读论文 了解相应的技术细节
Dialogue: 0,0:10:05.32,0:10:14.46,Default,,0,0,0,,后续我们会在幻灯片给出的地址上开源我们的编译器 
Dialogue: 0,0:10:14.46,0:10:17.96,Default,,0,0,0,,这样大家可以更好地了解编译器的实现细节
Dialogue: 0,0:10:17.96,0:10:21.24,Default,,0,0,0,,我认为这些特性都很不错
Dialogue: 0,0:10:21.24,0:10:25.47,Default,,0,0,0,,例如 我们可以使用随机类型、虚函数等 
Dialogue: 0,0:10:25.47,0:10:32.68,Default,,0,0,0,,从源代码阶段 而不是从后端原语阶段 实现不经意RAM协议
Dialogue: 0,0:10:34.52,0:10:39.77,Default,,0,0,0,,有了这些编程接口抽象 开发人员该怎么做呢？
Dialogue: 0,0:10:39.77,0:10:44.04,Default,,0,0,0,,例如 我们希望实现一个稀疏图算法
Dialogue: 0,0:10:44.04,0:10:49.76,Default,,0,0,0,,我们已经有了编程接口抽象这样一个武器库了
Dialogue: 0,0:10:49.76,0:10:56.81,Default,,0,0,0,,假设我们想要实现稀疏Dijkstra最短距离算法
Dialogue: 0,0:10:56.81,0:11:02.35,Default,,0,0,0,,我们可以选取适当的不经意数据结构 这里要选择不经意堆
Dialogue: 0,0:11:02.35,0:11:09.21,Default,,0,0,0,,随后 我们使用循环合并抽象实现相应的算法
Dialogue: 0,0:11:10.30,0:11:19.37,Default,,0,0,0,,通过使用这些工具 我们实现了3个不同的稀疏图算法
Dialogue: 0,0:11:19.37,0:11:21.77,Default,,0,0,0,,整个流程好像都走得通
Dialogue: 0,0:11:21.77,0:11:32.28,Default,,0,0,0,,但我们得到了一个超出期望的结果 我们实现的算法从理论角度也得到了突破
Dialogue: 0,0:11:32.28,0:11:39.34,Default,,0,0,0,,所有3个算法的渐进复杂度都比当前最优算法的渐进复杂度低
Dialogue: 0,0:11:39.34,0:11:43.50,Default,,0,0,0,,这个结论令我们感到十分惊讶
Dialogue: 0,0:11:43.50,0:11:49.80,Default,,0,0,0,,如果想了解算法的更多细节 请阅读我们的论文
Dialogue: 0,0:11:51.32,0:11:54.14,Default,,0,0,0,,开发人员具体该做些什么呢？
Dialogue: 0,0:11:54.14,0:12:04.30,Default,,0,0,0,,我在几分钟之前已经向大家许诺过了 我会为大家介绍一个编程接口抽象：循环合并
Dialogue: 0,0:12:04.30,0:12:10.51,Default,,0,0,0,,这是非常细节的内容了
Dialogue: 0,0:12:10.51,0:12:19.98,Default,,0,0,0,,在安全计算中 实现秘密循环是非常有挑战性的工作
Dialogue: 0,0:12:19.98,0:12:27.58,Default,,0,0,0,,因为循环次数本身就会泄露信息
Dialogue: 0,0:12:27.58,0:12:33.23,Default,,0,0,0,,这里我们允许编程人员编写有上界循环次数限制的循环语句
Dialogue: 0,0:12:33.23,0:12:43.76,Default,,0,0,0,,例如 我们允许协议保护循环次数 但我们要求开发人员公开告知循环次数的上限
Dialogue: 0,0:12:43.76,0:12:45.98,Default,,0,0,0,,这是一个嵌套循环代码 
Dialogue: 0,0:12:45.98,0:12:51.87,Default,,0,0,0,,这里有趣的地方在于 第4行到第7行的内部循环中
Dialogue: 0,0:12:53.12,0:13:01.61,Default,,0,0,0,,循环次数上界m并不是外部循环中每次迭代的最大迭代次数上界
Dialogue: 0,0:13:01.61,0:13:07.28,Default,,0,0,0,,而是两层嵌套代码中 内部循环的总执行次数上界
Dialogue: 0,0:13:07.28,0:13:09.55,Default,,0,0,0,,这样我们可以避免重复的执行过程
Dialogue: 0,0:13:09.55,0:13:16.97,Default,,0,0,0,,例如 如果我们按照传统方法给出上界 则总迭代次数是n•m
Dialogue: 0,0:13:16.97,0:13:21.21,Default,,0,0,0,,但这样设置的总迭代次数是n+m
Dialogue: 0,0:13:22.49,0:13:29.80,Default,,0,0,0,,我们的编译器会分析这段代码 自动将此类形式的代码转换成右下的代码形式
Dialogue: 0,0:13:29.80,0:13:38.68,Default,,0,0,0,,这段代码看起来像是一个状态机 这样就不会为算法引入额外的复杂度了
Dialogue: 0,0:13:40.03,0:13:44.60,Default,,0,0,0,,应用所有这些技术以后 我们能得到什么呢？
Dialogue: 0,0:13:44.60,0:13:52.16,Default,,0,0,0,,我之前已经提到 实现矩阵分解算法涉及的人力开销大约为1年1.5个研究者
Dialogue: 0,0:13:52.16,0:13:54.83,Default,,0,0,0,,如果使用ObliVM呢？
Dialogue: 0,0:13:54.83,0:13:58.15,Default,,0,0,0,,结果非常令人惊讶 只需要一天就够了
Dialogue: 0,0:13:58.15,0:14:02.54,Default,,0,0,0,,一个博士研究生只需要一天就可以实现全部功能
Dialogue: 0,0:14:02.54,0:14:11.60,Default,,0,0,0,,你可能会想 实现结果是否高效？可能自动化的实现结果并不高效
Dialogue: 0,0:14:11.60,0:14:16.30,Default,,0,0,0,,事实上 我们的实现的算法效率要高10到20倍
Dialogue: 0,0:14:16.30,0:14:17.96,Default,,0,0,0,,因此实现结果甚至更高效了
Dialogue: 0,0:14:17.96,0:14:20.00,Default,,0,0,0,,这就是我们现在得到的优化结果
Dialogue: 0,0:14:20.00,0:14:28.56,Default,,0,0,0,,我相信ObliVM对于所有安全计算开发者来说都是一个福音
Dialogue: 0,0:14:29.52,0:14:34.70,Default,,0,0,0,,我们深入解析一下各个优化点所带来的性能提升情况
Dialogue: 0,0:14:34.70,0:14:44.04,Default,,0,0,0,,我们这里给出的是Dijkstra算法的实现结果 论文中给出了更多的实现结果
Dialogue: 0,0:14:44.04,0:14:50.83,Default,,0,0,0,,虽然我们这里只关注ObliVM的编程语言部分
Dialogue: 0,0:14:50.83,0:14:58.62,Default,,0,0,0,,但实际上ObliVM拥有一个经过深度优化的后端ObliVM-SC 此后端代码也开源了
Dialogue: 0,0:14:58.62,0:15:02.78,Default,,0,0,0,,大家可以访问我们的网站 获取源代码链接
Dialogue: 0,0:15:02.78,0:15:10.36,Default,,0,0,0,,我们实现了一个当前最优的电路ORAM 此ORAM专门为安全计算进行优化
Dialogue: 0,0:15:10.36,0:15:23.57,Default,,0,0,0,,我们将我们的系统和之前在CCS 2012上公开的最佳结果进行了对比
Dialogue: 0,0:15:23.57,0:15:31.28,Default,,0,0,0,,电路ORAM本身可以为我们带来50倍的性能提升
Dialogue: 0,0:15:31.28,0:15:37.32,Default,,0,0,0,,编程语言和编译器可以为我们带来2500倍的性能提升
Dialogue: 0,0:15:37.32,0:15:41.63,Default,,0,0,0,,我们进一步对后后端的其它部分进行了深度优化
Dialogue: 0,0:15:41.63,0:15:44.43,Default,,0,0,0,,可以在我们的论文中找到相应的技术细节描述
Dialogue: 0,0:15:44.43,0:15:49.20,Default,,0,0,0,,这些深度优化可以为我们带来7倍的性能提升
Dialogue: 0,0:15:49.20,0:15:55.60,Default,,0,0,0,,总体来说 我们获得了大约100,000倍的性能提升 这是很大的性能提升倍数
Dialogue: 0,0:15:55.60,0:16:00.01,Default,,0,0,0,,这里给大家一个更直观的方案效率描述
Dialogue: 0,0:16:00.01,0:16:07.28,Default,,0,0,0,,2012年在同一篇论文中 他们在1GB数据集上执行了二分搜索算法
Dialogue: 0,0:16:07.28,0:16:13.55,Default,,0,0,0,,一次单独问询的计算时间大约为12小时
Dialogue: 0,0:16:13.55,0:16:15.04,Default,,0,0,0,,现在情况又怎么样呢？
Dialogue: 0,0:16:15.04,0:16:23.47,Default,,0,0,0,,使用我们的ObliVM框架 每次问询的执行时间仅为7.3秒
Dialogue: 0,0:16:25.58,0:16:31.77,Default,,0,0,0,,我们还将我们的SCVM框架与不安全的解决方案进行了效率对比
Dialogue: 0,0:16:31.77,0:16:39.74,Default,,0,0,0,,也就是说 我们直接在计算机上执行明文程序 从而对比效率
Dialogue: 0,0:16:39.74,0:16:41.26,Default,,0,0,0,,我们计算了效率损失量
Dialogue: 0,0:16:41.26,0:16:44.64,Default,,0,0,0,,效率损失量相对还是可以接受的
Dialogue: 0,0:16:44.64,0:16:52.84,Default,,0,0,0,,对于分布式GWAS 效率损失仅为130倍
Dialogue: 0,0:16:52.84,0:16:58.80,Default,,0,0,0,,我们可以期待 未来这一数字可能会进一步降低
Dialogue: 0,0:16:59.87,0:17:10.52,Default,,0,0,0,,有很多合作方都与我们合作 ObliVM已经在多个场景下得到了应用
Dialogue: 0,0:17:10.52,0:17:21.02,Default,,0,0,0,,我们刚刚赢得了3月份举办的基因分析竞赛 这是大约2个月前举办的竞赛
Dialogue: 0,0:17:23.13,0:17:35.80,Default,,0,0,0,,未来 我们希望在ObliVM框架的基础上实现更多的密码学计算任务 如同态加密等
Dialogue: 0,0:17:35.80,0:17:39.96,Default,,0,0,0,,非常感谢大家 这就是我讲座的全部内容了 接下来我可以回答一些问题
Dialogue: 0,0:17:47.55,0:17:51.95,Default,,0,0,0,,在演讲开始阶段你给出了一个二分搜索的例子
Dialogue: 0,0:17:51.95,0:17:56.09,Default,,0,0,0,,开发人员应该怎么实现二分搜索？开发人员需要写什么代码？
Dialogue: 0,0:17:56.09,0:18:00.35,Default,,0,0,0,,你指的是哪个例子？
Dialogue: 0,0:18:00.35,0:18:05.13,Default,,0,0,0,,在最开始的地方 你给出了一个二分搜索的例子 那时候你提到…
Dialogue: 0,0:18:05.13,0:18:17.90,Default,,0,0,0,,这张图中左侧是开发人员实现循环合并时要编写的代码
Dialogue: 0,0:18:17.90,0:18:21.50,Default,,0,0,0,,你提到了二分搜索的例子 对吧？
Dialogue: 0,0:18:21.50,0:18:22.00,Default,,0,0,0,,是的
Dialogue: 0,0:18:22.00,0:18:23.85,Default,,0,0,0,,我觉得用二分搜索举例子会比较好
Dialogue: 0,0:18:23.85,0:18:26.97,Default,,0,0,0,,开发人员要做的事情是…
Dialogue: 0,0:18:27.85,0:18:30.42,Default,,0,0,0,,我们回到那页幻灯片上
Dialogue: 0,0:18:32.57,0:18:33.34,Default,,0,0,0,,在这里
Dialogue: 0,0:18:33.34,0:18:33.80,Default,,0,0,0,,就是这里
Dialogue: 0,0:18:33.80,0:18:39.55,Default,,0,0,0,,这就是开发人员需要编写的代码… 我看看这个代码能不能编译通过…
Dialogue: 0,0:18:39.55,0:18:44.04,Default,,0,0,0,,是的 可以用我们的ObliVM编译器编译这个程序
Dialogue: 0,0:18:44.04,0:18:48.96,Default,,0,0,0,,编译器会自主处理内存访问过程
Dialogue: 0,0:18:48.96,0:18:51.23,Default,,0,0,0,,是的 是的 编译器会识别相应的模块
Dialogue: 0,0:18:51.23,0:18:56.04,Default,,0,0,0,,判断哪些部分要替换为ORAM 哪些部分不需要替换
Dialogue: 0,0:18:56.04,0:19:04.38,Default,,0,0,0,,ObliVM是不是有一种潜在使用方法 就是让ObliVM输出C代码 而不是电路
Dialogue: 0,0:19:04.38,0:19:10.44,Default,,0,0,0,,这样我们就可以把任意一个程序输入给ObliVM 使得程序无法被旁路攻击？
Dialogue: 0,0:19:10.44,0:19:13.61,Default,,0,0,0,,这是一个非常好的问题
Dialogue: 0,0:19:13.61,0:19:20.49,Default,,0,0,0,,一个非常有趣的事实是 我们的ObliVM编译器输出的是Java代码
Dialogue: 0,0:19:20.92,0:19:21.31,Default,,0,0,0,,明白
Dialogue: 0,0:19:21.31,0:19:27.28,Default,,0,0,0,,随后 执行Java代码 会生成一个电路
Dialogue: 0,0:19:27.28,0:19:31.71,Default,,0,0,0,,所以我觉得你提的问题非常好
Dialogue: 0,0:19:31.71,0:19:41.69,Default,,0,0,0,,我认为未来一个很有趣的研究方向是 如何阻止ObliVM编译器遭到旁路攻击
Dialogue: 0,0:19:41.69,0:19:42.54,Default,,0,0,0,,好的 谢谢
Dialogue: 0,0:19:42.54,0:19:43.90,Default,,0,0,0,,谢谢你
Dialogue: 0,0:19:46.54,0:19:47.69,Default,,0,0,0,,什么？
Dialogue: 0,0:19:54.60,0:19:58.14,Default,,0,0,0,,你可以使用麦克风的
Dialogue: 0,0:20:02.97,0:20:06.28,Default,,0,0,0,,我们的编译器没办法被旁路攻击
Dialogue: 0,0:20:06.28,0:20:11.20,Default,,0,0,0,,如果你直接编写类似这样的代码 编译的输出结果是通用ORAM程序
Dialogue: 0,0:20:11.20,0:20:14.52,Default,,0,0,0,,但你也可以调用我们提供的不经意数据结构
Dialogue: 0,0:20:14.52,0:20:17.87,Default,,0,0,0,,我们在不经意数据结构中实现了二分搜索树
Dialogue: 0,0:20:17.87,0:20:24.94,Default,,0,0,0,,如果直接调用不经意数据结构抽象接口 编译时间会减少log(n)倍
Dialogue: 0,0:20:25.60,0:20:26.20,Default,,0,0,0,,明白
Dialogue: 0,0:20:29.98,0:20:34.17,Default,,0,0,0,,很容易让编译器输出C代码 修改后端编译器即可
Dialogue: 0,0:20:34.17,0:20:42.03,Default,,0,0,0,,比较困难的点在于前端 如何编译得到一个高效的电路
Dialogue: 0,0:20:46.00,0:20:47.29,Default,,0,0,0,,感谢Elaine的解释
Dialogue: 0,0:20:49.45,0:20:51.24,Default,,0,0,0,,是的 感谢Elaine
Dialogue: 0,0:20:51.24,0:20:54.57,Default,,0,0,0,,再次感谢我们的演讲者
Dialogue: 0,0:20:53.03,0:20:58.03,Default,,0,0,0,,{\pos(639,49.999)}听译、时间轴：刘巍然（学酥）
