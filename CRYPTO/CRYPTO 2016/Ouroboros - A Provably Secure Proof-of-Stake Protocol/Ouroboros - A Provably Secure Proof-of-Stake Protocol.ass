[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 原始视频_Ouroboros_可证明安全的权益证明协议.mp4
Video File: 原始视频_Ouroboros_可证明安全的权益证明协议.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 94
Active Line: 123
Video Position: 47861

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,68,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2.99999,2.99999,2,16,16,16,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(958.5,74.999)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:05.68,0:00:11.46,Default,,0,0,0,,感谢大家前来聆听本会场的最后一个讲座 这一天确实比较漫长
Dialogue: 0,0:00:12.20,0:00:18.66,Default,,0,0,0,,在本讲座中 我将向大家介绍Ouroboros 一个可证明安全的权益证明协议
Dialogue: 0,0:00:18.66,0:00:23.14,Default,,0,0,0,,这是我和Alexander Russell、Bernardo David和Roman Oliynykov的工作
Dialogue: 0,0:00:24.08,0:00:33.12,Default,,0,0,0,,既然大家来到本会场听讲座 应该已经了解我们想实现的账本目标了
Dialogue: 0,0:00:33.12,0:00:39.40,Default,,0,0,0,,我们的目标是构造一个协议 实现一个健壮的交易账本
Dialogue: 0,0:00:39.40,0:00:47.72,Default,,0,0,0,,这是由Juan Garay、我、以及Nikos Leonardos提出的目标 论文缩写为GKL
Dialogue: 0,0:00:47.72,0:00:50.82,Default,,0,0,0,,我们给出了形式化定义 这就是我们的目标
Dialogue: 0,0:00:50.82,0:00:56.24,Default,,0,0,0,,这也引出了其它一些后续工作 这些工作对模型进行了精炼 给出了更好的定义
Dialogue: 0,0:00:56.24,0:00:58.32,Default,,0,0,0,,一些工作也出现在本会场前面的讲座中
Dialogue: 0,0:00:58.32,0:01:04.40,Default,,0,0,0,,我们现在可以认为 我们最终得到了一个基于仿真的、可组合的目标定义
Dialogue: 0,0:01:04.40,0:01:09.86,Default,,0,0,0,,一旦有了设计目标 有了很明确的方向 我们就会问这样一个问题：
Dialogue: 0,0:01:10.96,0:01:13.60,Default,,0,0,0,,我们是否知道实现这一目标的最佳方法？
Dialogue: 0,0:01:15.26,0:01:20.06,Default,,0,0,0,,而本会场最后这个讲座的目标就是要回答这个问题
Dialogue: 0,0:01:21.78,0:01:28.92,Default,,0,0,0,,我们知道 可以通过比特币等其它我所引用的前人工作所提到的技术来实现账本目标
Dialogue: 0,0:01:29.92,0:01:38.66,Default,,0,0,0,,但我们也知道 在现实生活中执行的协议效果告诉我们
Dialogue: 0,0:01:38.66,0:01:42.80,Default,,0,0,0,,目前实现的账本目标具有扩展性差、能源消耗多等缺点
Dialogue: 0,0:01:43.72,0:01:47.36,Default,,0,0,0,,我们是否可以用一种更高效的方法实现账本目标？
Dialogue: 0,0:01:47.36,0:01:55.24,Default,,0,0,0,,至少到目前为止 我们有一个称为权益证明的思想
Dialogue: 0,0:01:57.12,0:02:02.96,Default,,0,0,0,,比特币社区早在2011年就提出了这个想法
Dialogue: 0,0:02:02.96,0:02:06.68,Default,,0,0,0,,这可能是一种设计高效账本记录方式的方法
Dialogue: 0,0:02:07.36,0:02:09.68,Default,,0,0,0,,权益证明的基本思想和技术背景是什么呢？
Dialogue: 0,0:02:11.36,0:02:20.98,Default,,0,0,0,,前面其它学者的讲座中也强调 可以认为比特币执行过程的核心目标是实现选举过程
Dialogue: 0,0:02:20.98,0:02:24.66,Default,,0,0,0,,下一个区块是通过选举来产生的
Dialogue: 0,0:02:24.66,0:02:32.90,Default,,0,0,0,,某个协议参与方 也就是矿工 会被选择上 有权利对链进行扩展
Dialogue: 0,0:02:34.34,0:02:38.18,Default,,0,0,0,,被选择上的概率正比于参与方计算哈希值的能力
Dialogue: 0,0:02:38.18,0:02:42.42,Default,,0,0,0,,同时 全网通过一定的规则来解决碰撞问题
Dialogue: 0,0:02:42.42,0:02:46.04,Default,,0,0,0,,一般使用最长链规则或最大难度链规则
Dialogue: 0,0:02:47.76,0:02:52.16,Default,,0,0,0,,权益证明背后也遵从类似的思想
Dialogue: 0,0:02:52.16,0:03:01.02,Default,,0,0,0,,但权益证明使用实体所拥有的权益来完成选取 个体拥有的权益同样体现在账本上
Dialogue: 0,0:03:02.50,0:03:11.38,Default,,0,0,0,,权益证明将个体的权益考虑其中 通过随机化过程选举出下一个扩展链的实体
Dialogue: 0,0:03:12.66,0:03:19.94,Default,,0,0,0,,从某种角度上看 这一过程的基本逻辑也反应出当前现实生活中协议的执行逻辑
Dialogue: 0,0:03:19.94,0:03:26.04,Default,,0,0,0,,因为在现实生活中 我们可以用资金来购买哈希计算能力
Dialogue: 0,0:03:26.04,0:03:34.28,Default,,0,0,0,,通过投入更多的资金 你可以提高在系统中被选择上的概率
Dialogue: 0,0:03:34.28,0:03:39.58,Default,,0,0,0,,但权益证明从某种程度上看舍弃了协议执行过程中物理层面的印记
Dialogue: 0,0:03:39.58,0:03:51.78,Default,,0,0,0,,直接使用区块链本身记录的权益作为实体选举过程的参考 用于对区块链进行扩展
Dialogue: 0,0:03:53.02,0:04:02.14,Default,,0,0,0,,我们可以按照我们感兴趣的两个维度 对所有的协议进行分类
Dialogue: 0,0:04:02.14,0:04:11.50,Default,,0,0,0,,{\pos(958.5,74.999)} @译者注：这里作者称x轴表示性能或消耗能量 应该为口误
Dialogue: 0,0:04:02.14,0:04:11.50,Default,,0,0,0,,图中y轴表示执行协议的性能或消耗的能量高低 越大表示性能越好 能量消耗越低
Dialogue: 0,0:04:11.50,0:04:14.30,Default,,0,0,0,,x轴表示协议支持的去中心化程度
Dialogue: 0,0:04:14.30,0:04:18.96,Default,,0,0,0,,当同时考虑这两个因素时 我们可以认为我们的目标是实现一个账本
Dialogue: 0,0:04:18.96,0:04:24.08,Default,,0,0,0,,一方面我们已经有了中心化的数据库 很容易知道此数据库位于图中的左上角
Dialogue: 0,0:04:24.08,0:04:29.74,Default,,0,0,0,,我们也有比特币 它位于图中的右下角 更去中心化 但能源消耗很大
Dialogue: 0,0:04:29.74,0:04:37.06,Default,,0,0,0,,还可以直接将其它业务场景下的协商协议引入账本
Dialogue: 0,0:04:37.06,0:04:41.58,Default,,0,0,0,,我们可以看到 这种账本与比特币相比更加中心化
Dialogue: 0,0:04:41.58,0:04:48.38,Default,,0,0,0,,并且效率比中心化数据库低 毕竟在中心化数据库中 单一节点失效会使得全节点失效
Dialogue: 0,0:04:48.38,0:04:59.38,Default,,0,0,0,,如果我们可以设计出权益证明协议 至少我们认为其有希望位于图中的右上角
Dialogue: 0,0:04:59.38,0:05:07.54,Default,,0,0,0,,因为权益证明协议会比通过协商协议实现的账本更加去中心化
Dialogue: 0,0:05:07.54,0:05:11.92,Default,,0,0,0,,权益的分布情况会随时间的变化而变化
Dialogue: 0,0:05:13.18,0:05:18.64,Default,,0,0,0,,但同时 协议可以实现每一次心跳都生成一个区块
Dialogue: 0,0:05:18.64,0:05:26.40,Default,,0,0,0,,如果执行协议的参与方变得特别多 协议的执行结果也不会变得太过糟糕
Dialogue: 0,0:05:26.40,0:05:35.04,Default,,0,0,0,,如果能实现这样一个协议 我们就既可以做到去中心化 又可以做到协议高效执行
Dialogue: 0,0:05:35.04,0:05:43.28,Default,,0,0,0,,在最早期刚提出权益证明思想的时候 人们认为权益证明有可能达成上述目的
Dialogue: 0,0:05:43.28,0:05:52.48,Default,,0,0,0,,但很快 人们就意识到 设计权益证明协议会遇到很严重的挑战
Dialogue: 0,0:05:52.48,0:05:58.10,Default,,0,0,0,,第一个挑战是存在所谓的“粉碎攻击”
Dialogue: 0,0:05:58.10,0:06:08.18,Default,,0,0,0,,因为选举过程成为了一个可计算协议 并且选取过程也会反应在区块链上
Dialogue: 0,0:06:08.18,0:06:17.28,Default,,0,0,0,,与比特币工作量证明协议相比 攻击者可以绕过协议的理想执行过程
Dialogue: 0,0:06:17.28,0:06:25.52,Default,,0,0,0,,部分实体可能利用其计算能力使协议的执行结果发生偏斜 使结果对自己有利
Dialogue: 0,0:06:25.52,0:06:32.20,Default,,0,0,0,,所有基于权益证明的区块链协议都会面临粉碎攻击问题
Dialogue: 0,0:06:32.20,0:06:37.36,Default,,0,0,0,,另一个被广泛研究的权益证明协议攻击方法称为“无权益风险”攻击
Dialogue: 0,0:06:37.36,0:06:45.20,Default,,0,0,0,,这一攻击反应的事实是 权益拥有者没必要严格按照协议对指定的链进行扩展
Dialogue: 0,0:06:45.20,0:06:48.10,Default,,0,0,0,,权益拥有者可以尝试同时扩展多个链
Dialogue: 0,0:06:48.10,0:06:51.80,Default,,0,0,0,,最后 权益证明还面临一个循环的问题
Dialogue: 0,0:06:51.80,0:06:55.90,Default,,0,0,0,,从某种角度看 我们在区块链上执行一个协议 产生随机量
Dialogue: 0,0:06:55.90,0:07:00.96,Default,,0,0,0,,但与此同时 协议的安全性也就不得不依赖于区块链
Dialogue: 0,0:07:00.96,0:07:08.74,Default,,0,0,0,,因此 如果要证明协议的安全性 我们要绕开随机量生成与区块链安全性的约束关系
Dialogue: 0,0:07:10.14,0:07:11.64,Default,,0,0,0,,这就是我们的境地
Dialogue: 0,0:07:11.64,0:07:18.82,Default,,0,0,0,,现在的问题是 是否可以只使用权益证明思想实现我们期望的账本目标？
Dialogue: 0,0:07:20.34,0:07:23.90,Default,,0,0,0,,我们简单论述一下协议 假定全网是同步的
Dialogue: 0,0:07:23.90,0:07:27.50,Default,,0,0,0,,时间按轮数进行划分 每一轮称为一个时间槽
Dialogue: 0,0:07:27.50,0:07:29.72,Default,,0,0,0,,网络中的每一条消息都可以在全网扩散
Dialogue: 0,0:07:29.72,0:07:33.14,Default,,0,0,0,,在前面的两个讲座中 大家应该也看到过与之相同的网络模型
Dialogue: 0,0:07:33.14,0:07:37.74,Default,,0,0,0,,攻击者非常激进 这意味着攻击者掌握了很多攻击能力
Dialogue: 0,0:07:37.74,0:07:43.36,Default,,0,0,0,,他可以传递消息、篡改消息、在消息中注入自己想要的内容、重排列消息接收顺序
Dialogue: 0,0:07:43.36,0:07:49.98,Default,,0,0,0,,可以将一些消息只发送给部分参与方 可以拒绝将自己接收的消息发送给别人
Dialogue: 0,0:07:51.46,0:07:58.20,Default,,0,0,0,,在这样的场景下 我们首先来看看我们协议的执行过程
Dialogue: 0,0:07:58.20,0:08:07.06,Default,,0,0,0,,这是协议执行的第一步 此时我们需要假设权益是静态的
Dialogue: 0,0:08:07.06,0:08:12.22,Default,,0,0,0,,我们拥有固定量级的权益拥有者 每一位权益拥有者的权益都在最开始时初始化好
Dialogue: 0,0:08:12.22,0:08:14.72,Default,,0,0,0,,每一位权益拥有者都拥有特定的权益量
Dialogue: 0,0:08:14.72,0:08:20.24,Default,,0,0,0,,权益量是预定义好的 权益拥有者的权益量写在创始区块中
Dialogue: 0,0:08:20.24,0:08:26.78,Default,,0,0,0,,创世区块还包含一个种子 可以认为这个种子是一个随机字符串
Dialogue: 0,0:08:26.78,0:08:37.98,Default,,0,0,0,,种子可以为每一个时间槽随机选择并指派一个所谓的领导者
Dialogue: 0,0:08:39.74,0:08:45.72,Default,,0,0,0,,这个领导者将负责在特定的时间槽内生成区块
Dialogue: 0,0:08:45.72,0:08:51.70,Default,,0,0,0,,对于每一个时间槽 只有一个实体负责生成区块
Dialogue: 0,0:08:51.70,0:08:59.52,Default,,0,0,0,,由于种子包含在创始区块中 因此系统已经确定好每一个时间槽所对应的领导者了
Dialogue: 0,0:09:01.12,0:09:09.96,Default,,0,0,0,,时间槽领导者的采样权重源于权益拥有者所拥有的权益分布
Dialogue: 0,0:09:09.96,0:09:15.14,Default,,0,0,0,,这意味着拥有的权益越多 权益拥有者越有可能被选为特定时间槽的领导者
Dialogue: 0,0:09:15.14,0:09:18.14,Default,,0,0,0,,除此之外 整个选举过程是独立随机的
Dialogue: 0,0:09:18.14,0:09:21.36,Default,,0,0,0,,现在 协议开始执行
Dialogue: 0,0:09:21.36,0:09:26.30,Default,,0,0,0,,所有权益拥有者拥有一个公钥和一个私钥 用于生成数字签名
Dialogue: 0,0:09:26.30,0:09:31.48,Default,,0,0,0,,现在 对于每一个时间槽 协议的执行过程都非常简单
Dialogue: 0,0:09:31.48,0:09:36.58,Default,,0,0,0,,每一个时间槽都指定了一个领导者 这个领导者将生成一个区块
Dialogue: 0,0:09:38.48,0:09:40.60,Default,,0,0,0,,但是 实际中实体并不会严格执行此协议
Dialogue: 0,0:09:40.60,0:09:47.84,Default,,0,0,0,,例如 某个时间槽领导者可能处于离线状态 他也可能被攻击者所控制 拒绝执行协议
Dialogue: 0,0:09:47.84,0:09:56.96,Default,,0,0,0,,此种情况下 整个协议仍然继续执行 参与方会根据最长链规则扩展前一个区块
Dialogue: 0,0:09:56.96,0:10:03.76,Default,,0,0,0,,协议非常简单 和比特币基本完全一致 但参与方不需要在解决困难问题了
Dialogue: 0,0:10:05.04,0:10:09.90,Default,,0,0,0,,整个协议非常简单 但如何分析这个协议呢？
Dialogue: 0,0:10:09.90,0:10:14.98,Default,,0,0,0,,幻灯片给出了我们对协议的安全性分析方法
Dialogue: 0,0:10:14.98,0:10:20.52,Default,,0,0,0,,我们需要了解的第一个重要目标是所谓的“特征字符串”
Dialogue: 0,0:10:20.52,0:10:25.56,Default,,0,0,0,,特征字符串的长度与系统执行过程涉及到的时间槽数量一致
Dialogue: 0,0:10:25.56,0:10:34.40,Default,,0,0,0,,当时间槽归属诚实实体 则对应字符为0 如果归属恶意实体 则对应字符为1
Dialogue: 0,0:10:34.40,0:10:39.06,Default,,0,0,0,,注意到参与方本身无法知道特征字符串的取值
Dialogue: 0,0:10:39.06,0:10:54.04,Default,,0,0,0,,但我们可以观察协议执行过程和攻击者的执行策略获取特征字符串的取值
Dialogue: 0,0:10:54.04,0:11:00.36,Default,,0,0,0,,假定幻灯片上给出的就是协议执行过程中生成的特征字符串
Dialogue: 0,0:11:00.36,0:11:03.74,Default,,0,0,0,,我们来看看协议是如何执行的
Dialogue: 0,0:11:03.74,0:11:10.86,Default,,0,0,0,,根据协议执行过程 我们可以定义一个区块树 我们称之为“分叉”
Dialogue: 0,0:11:10.86,0:11:16.94,Default,,0,0,0,,可以通过特征字符串生成这一区块树
Dialogue: 0,0:11:16.94,0:11:22.82,Default,,0,0,0,,最开始的特征字符为0 对应的是创始区块 我们假定创始区块的参与方总是诚实的
Dialogue: 0,0:11:22.82,0:11:29.28,Default,,0,0,0,,现在 我们有了第一个时间槽 一个诚实的参与方生成了区块1
Dialogue: 0,0:11:29.28,0:11:33.50,Default,,0,0,0,,接下来 我们看到了一个关联了攻击者的时间槽
Dialogue: 0,0:11:33.50,0:11:38.28,Default,,0,0,0,,不失一般性 攻击者不一定非要在轮到他操作的一瞬间就采取行动
Dialogue: 0,0:11:38.28,0:11:42.46,Default,,0,0,0,,攻击者可以等待 当时间槽将要切换到诚实参与方操作的时候再采取行动
Dialogue: 0,0:11:42.46,0:11:44.40,Default,,0,0,0,,攻击者可以执行下述攻击行为
Dialogue: 0,0:11:44.40,0:11:53.92,Default,,0,0,0,,控制时间槽2的攻击者将产生一个区块 使得诚实参与方将在3的位置生成区块
Dialogue: 0,0:11:53.92,0:11:58.84,Default,,0,0,0,,现在 区块链将会分为两个分支
Dialogue: 0,0:11:58.84,0:12:05.76,Default,,0,0,0,,因此 这个诚实参与方将会沿着上面的分支进行扩展 我们称此现象为一个尖叉
Dialogue: 0,0:12:07.16,0:12:11.36,Default,,0,0,0,,整个攻击过程会导致区块链出现3个分支
Dialogue: 0,0:12:11.36,0:12:22.24,Default,,0,0,0,,而攻击者可以规划整个攻击方式 他可以强制沿着中间分支扩展区块链
Dialogue: 0,0:12:22.24,0:12:25.46,Default,,0,0,0,,我们来看看位置5所发生的事情
Dialogue: 0,0:12:25.46,0:12:32.24,Default,,0,0,0,,在这一时刻 攻击者控制了时间槽4 他在下方生成区块 并告知时间槽5关联的参与方
Dialogue: 0,0:12:32.24,0:12:40.64,Default,,0,0,0,,注意到此参与方会发现 包含创始区块在内 中间和下方两个分支的长度都为3
Dialogue: 0,0:12:40.64,0:12:49.46,Default,,0,0,0,,由于攻击者可以控制消息的发送顺序 他可以说服参与方在5的位置扩展区块链
Dialogue: 0,0:12:49.46,0:12:52.14,Default,,0,0,0,,攻击者随后通过类似的方法在6的位置扩展区块链
Dialogue: 0,0:12:52.14,0:12:58.26,Default,,0,0,0,,最后 攻击者说服参与方在9的位置生成新的区块
Dialogue: 0,0:12:58.26,0:13:07.60,Default,,0,0,0,,我们观察到的结果是 前面所描述的简单协议 其实际执行结果可能非常复杂
Dialogue: 0,0:13:07.60,0:13:12.14,Default,,0,0,0,,这是因为攻击者可以控制诚实参与方 使其对区块链上不同的位置进行扩展
Dialogue: 0,0:13:12.14,0:13:16.58,Default,,0,0,0,,这会出现什么问题呢？
Dialogue: 0,0:13:16.58,0:13:25.18,Default,,0,0,0,,从工作量证明开始 我们已经广泛研究了共识机制 如何从共识机制角度考虑此协议？
Dialogue: 0,0:13:25.18,0:13:27.72,Default,,0,0,0,,正如所见 我们面临的情况和工作量证明不太一样
Dialogue: 0,0:13:27.72,0:13:32.06,Default,,0,0,0,,首先 攻击者的攻击难度会大幅降低
Dialogue: 0,0:13:32.06,0:13:39.04,Default,,0,0,0,,与基于工作量证明的协议执行过程相比 攻击者更容易实施攻击
Dialogue: 0,0:13:39.04,0:13:44.04,Default,,0,0,0,,为什么？因为攻击者可以事先知道哪个权益拥有者将会被激活
Dialogue: 0,0:13:44.04,0:13:48.98,Default,,0,0,0,,攻击者可以在不付出任何代价的前提下 在相同的时间槽中创建多个不同的区块
Dialogue: 0,0:13:48.98,0:13:56.30,Default,,0,0,0,,这与比特币的执行机制不同 在比特币中 攻击者需要投入计算资源来扩展区块链
Dialogue: 0,0:13:56.30,0:13:58.52,Default,,0,0,0,,但现在情况不一样了
Dialogue: 0,0:13:58.52,0:14:04.50,Default,,0,0,0,,最后 攻击者可以等到快到诚实节点行动的时候再采取行动
Dialogue: 0,0:14:04.50,0:14:09.64,Default,,0,0,0,,当时间槽指向攻击者自己时 他完全可以先等待 不采取任何行动
Dialogue: 0,0:14:09.64,0:14:16.40,Default,,0,0,0,,他可以等到诚实节点激活的时候再采取行动 他可以根据情况采取最佳攻击策略
Dialogue: 0,0:14:16.40,0:14:24.12,Default,,0,0,0,,因此 攻击者不需要提前告知其想如何扩展区块链
Dialogue: 0,0:14:24.12,0:14:29.18,Default,,0,0,0,,我们来观察一下特征字符串 幻灯片给出了两个特征字符串
Dialogue: 0,0:14:29.18,0:14:32.76,Default,,0,0,0,,在协议实际执行过程中 特征字符串的可能性有指数多个
Dialogue: 0,0:14:32.76,0:14:38.04,Default,,0,0,0,,攻击者更喜欢看到哪个特征字符串呢？
Dialogue: 0,0:14:38.04,0:14:44.90,Default,,0,0,0,,大家可以看到 很明显攻击者不喜欢结果为000的特征字符串
Dialogue: 0,0:14:44.90,0:14:51.10,Default,,0,0,0,,攻击者无法对这种特征字符串对应的区块链实施任何攻击 区块按顺序组织 没有分叉
Dialogue: 0,0:14:51.10,0:14:56.26,Default,,0,0,0,,另一方面 看看这个特征字符串00110001
Dialogue: 0,0:14:56.26,0:15:01.60,Default,,0,0,0,,攻击者完全可以对这个特征字符串对应的区块链实施攻击 我们称其为可分叉的
Dialogue: 0,0:15:01.60,0:15:02.70,Default,,0,0,0,,攻击者如何实施攻击？
Dialogue: 0,0:15:02.70,0:15:06.46,Default,,0,0,0,,大家可以看看 为何我们称此字符串是可分叉的呢？
Dialogue: 0,0:15:06.46,0:15:17.02,Default,,0,0,0,,仔细看看当前区块链的状态 如果你是下一个被激活的诚实参与方 你该如何行动？
Dialogue: 0,0:15:17.02,0:15:19.86,Default,,0,0,0,,我们来看看会发生什么
Dialogue: 0,0:15:19.86,0:15:33.36,Default,,0,0,0,,大家可以看到 攻击者有明确的自主权 决定产生分叉的时间上限和时间下限
Dialogue: 0,0:15:33.36,0:15:42.40,Default,,0,0,0,,这是因为上方分叉的长度为5 下方分叉的长度为4 但是攻击者控制着此时间槽
Dialogue: 0,0:15:42.40,0:15:52.22,Default,,0,0,0,,因此 当你作为诚实参与方生成区块时 你沿着哪个分叉进行扩展完全由攻击者决定
Dialogue: 0,0:15:52.22,0:15:59.10,Default,,0,0,0,,这种情况下攻击者可以成功实施攻击 此特征字符串比较糟糕 我们称其为可分叉
Dialogue: 0,0:15:59.10,0:16:08.16,Default,,0,0,0,,这里的核心点在于 如果我们随机选择一个特征字符串 其可分叉的概率有多大？
Dialogue: 0,0:16:08.16,0:16:11.18,Default,,0,0,0,,这就是安全性分析的核心点
Dialogue: 0,0:16:11.18,0:16:16.30,Default,,0,0,0,,为了明白这一点 我们需要引入两个很有帮助的参数
Dialogue: 0,0:16:16.30,0:16:18.44,Default,,0,0,0,,两个参数分别称为到达量和边缘量
Dialogue: 0,0:16:18.44,0:16:23.16,Default,,0,0,0,,我们首先要关注的是所谓的封闭分叉
Dialogue: 0,0:16:23.16,0:16:29.24,Default,,0,0,0,,封闭分叉指的是分叉的结尾区块与一个诚实参与方关联
Dialogue: 0,0:16:29.24,0:16:32.60,Default,,0,0,0,,区块树的叶子节点是一个诚实参与方
Dialogue: 0,0:16:32.60,0:16:36.98,Default,,0,0,0,,注意 我们不需要考虑结尾区块与攻击者关联的分叉
Dialogue: 0,0:16:36.98,0:16:41.40,Default,,0,0,0,,因为攻击者随时可以在适当的时间在与攻击者关联的分叉后方填充任意区块
Dialogue: 0,0:16:41.40,0:16:48.66,Default,,0,0,0,,对于一个封闭区块 我们可以定义两个很有用的参数
Dialogue: 0,0:16:48.66,0:16:58.28,Default,,0,0,0,,第一个参数是保留量 其表示攻击者可以在后方增加多少个区块
Dialogue: 0,0:16:58.28,0:17:06.32,Default,,0,0,0,,幻灯片上 上方分叉的保留量是3 因为后面有三个时间槽是属于攻击者的
Dialogue: 0,0:17:06.32,0:17:16.76,Default,,0,0,0,,例如 当诚实参与方在第3时间槽上激活时 攻击者可以保留3个区块 并增加到后方
Dialogue: 0,0:17:16.76,0:17:31.52,Default,,0,0,0,,同时 还可以定义另一个参数 称为间隔量 表示此分支成为主链所需的时间
Dialogue: 0,0:17:31.52,0:17:43.74,Default,,0,0,0,,如果我们用保留量减去间隔量 我们就定义了所谓的到达量
Dialogue: 0,0:17:43.74,0:17:50.56,Default,,0,0,0,,这个量告诉我们 此分叉需要多长时间才能成为主链
Dialogue: 0,0:17:50.56,0:17:58.18,Default,,0,0,0,,在我们的概率分析中 到达量和边缘量是两个非常重要的参数
Dialogue: 0,0:17:58.18,0:18:02.58,Default,,0,0,0,,好消息是 组合这几个参数后我们可以知道 如果一个特征字符串是可分叉的
Dialogue: 0,0:18:02.58,0:18:08.02,Default,,0,0,0,,当且仅当存在一个封闭区块 此区块的边缘量为0 或者至少为0
Dialogue: 0,0:18:08.02,0:18:11.62,Default,,0,0,0,,而边缘量指的是我们取最长链的到达量
Dialogue: 0,0:18:11.62,0:18:14.64,Default,,0,0,0,,将最长链的到达量与第二长链的到达量进行对比
Dialogue: 0,0:18:14.64,0:18:18.22,Default,,0,0,0,,并且计算这两个链到达量的差
Dialogue: 0,0:18:19.58,0:18:29.86,Default,,0,0,0,,我们应用到达量和边缘量建立了概率分析模型
Dialogue: 0,0:18:29.86,0:18:39.74,Default,,0,0,0,,我们会发现 当新的权益拥有者增加区块时 到达量和边缘量构成了随机游走过程
Dialogue: 0,0:18:39.74,0:18:49.28,Default,,0,0,0,,当特征字符为1时 表示此时间槽被攻击 此时到达量和边缘量都增加了1
Dialogue: 0,0:18:50.82,0:18:58.60,Default,,0,0,0,,另一方面 当特征字符为0时 到达量和边缘量都会降低
Dialogue: 0,0:18:58.60,0:19:04.66,Default,,0,0,0,,这一过程反应在幻灯片最下方的这行公式上
Dialogue: 0,0:19:04.66,0:19:07.82,Default,,0,0,0,,如果事实真的如此 则到达量和边缘量构成简单的随机游走过程
Dialogue: 0,0:19:07.82,0:19:11.82,Default,,0,0,0,,但实际的协议执行过程中 只有最下方情况到达量和边缘量都会降低
Dialogue: 0,0:19:11.82,0:19:14.60,Default,,0,0,0,,在处于最下方情况时 到达量和边缘量都会降低
Dialogue: 0,0:19:14.60,0:19:19.16,Default,,0,0,0,,但实际上 到达量不可能降低到小于0
Dialogue: 0,0:19:19.16,0:19:25.70,Default,,0,0,0,,如果到达量是0 则到达量保持为0 因为到达量描述了攻击者的攻击优势
Dialogue: 0,0:19:25.70,0:19:38.40,Default,,0,0,0,,这个迭代公式中非常有趣的一点是 如果边缘量为0 则到达量会降低
Dialogue: 0,0:19:38.40,0:19:46.04,Default,,0,0,0,,因为攻击者可以在牺牲到达量的条件下对边缘量进行补偿
Dialogue: 0,0:19:46.04,0:19:52.56,Default,,0,0,0,,现在 如果我们应用这个迭代公式 并且将此迭代公式应用在时间槽领导者采样实验中
Dialogue: 0,0:19:52.56,0:19:56.80,Default,,0,0,0,,我们实际上会得到一个二维随机游走过程
Dialogue: 0,0:19:56.80,0:20:05.18,Default,,0,0,0,,这个二维随机游走过程实际上非常简单 到达量和边缘量会交替为正或者为负
Dialogue: 0,0:20:05.18,0:20:08.44,Default,,0,0,0,,因此 这两个变量会构成一个简单的随机游走过程
Dialogue: 0,0:20:08.44,0:20:14.80,Default,,0,0,0,,但当到达量为正时 边缘量会降低 直到固定为0
Dialogue: 0,0:20:14.80,0:20:21.26,Default,,0,0,0,,因此 这个二维随机游走过程体现出了边缘量和到达量之间的相互关系
Dialogue: 0,0:20:22.52,0:20:30.06,Default,,0,0,0,,现在我们要考虑的问题是 当在这个随机游走过程中随机取一个长特征字符串
Dialogue: 0,0:20:30.06,0:20:34.40,Default,,0,0,0,,则最终得到边的边缘量至少为0的概率是多少
Dialogue: 0,0:20:34.40,0:20:42.16,Default,,0,0,0,,我们可以证明 这一情况出现的概率非常小 等于2^-√n乘以一个常数
Dialogue: 0,0:20:42.16,0:20:51.90,Default,,0,0,0,,关键点在于 我们可以把二维空间划分为3个区域 分别称为热区、脆弱区、冷区
Dialogue: 0,0:20:51.90,0:21:00.88,Default,,0,0,0,,脆弱区指的是边缘量和到达量的取值都接近为0
Dialogue: 0,0:21:00.88,0:21:03.76,Default,,0,0,0,,这实际上就是初始化状态
Dialogue: 0,0:21:03.76,0:21:10.42,Default,,0,0,0,,我们还有冷区 此时边缘值为负 此种情况下区块链是安全的
Dialogue: 0,0:21:10.42,0:21:13.78,Default,,0,0,0,,我们还有热区 此时区块链是不安全的
Dialogue: 0,0:21:13.78,0:21:22.28,Default,,0,0,0,,我们可以证明 在游戏开始时我们的初始状态为脆弱状态
Dialogue: 0,0:21:22.28,0:21:28.74,Default,,0,0,0,,从脆弱状态转移到热状态的概率无限接近于0 为2^-√n
Dialogue: 0,0:21:28.74,0:21:31.64,Default,,0,0,0,,但从脆弱状态转移到冷状态的概率为常数
Dialogue: 0,0:21:31.64,0:21:36.36,Default,,0,0,0,,核心观察结论在于 一旦转移到了冷状态 则区块链将永远为冷状态
Dialogue: 0,0:21:36.36,0:21:42.98,Default,,0,0,0,,也就是说 随机游走过程的位置已经远离脆弱区和热区 我们是安全的
Dialogue: 0,0:21:42.98,0:21:49.28,Default,,0,0,0,,由于转移到热区的概率是2^-√n 而转移到冷区的概率是常数
Dialogue: 0,0:21:49.28,0:21:55.82,Default,,0,0,0,,我们要做的是把时间划分成√n个区域 证明在任意一个处理过程中
Dialogue: 0,0:21:55.82,0:22:02.16,Default,,0,0,0,,区块链都会有很高的概率从脆弱状态转移到冷状态
Dialogue: 0,0:22:02.16,0:22:05.14,Default,,0,0,0,,这意味着我们是安全的
Dialogue: 0,0:22:05.14,0:22:10.28,Default,,0,0,0,,最后 这意味着获得一个可分叉特征字符串的概率也是可忽略的
Dialogue: 0,0:22:10.28,0:22:16.26,Default,,0,0,0,,有了这样一个基础协议 我们可以进一步设计出权益动态变化下的协议
Dialogue: 0,0:22:16.26,0:22:25.96,Default,,0,0,0,,在权益动态变化的条件下 我们要做的是在特定数量的时间槽中执行基础协议
Dialogue: 0,0:22:25.96,0:22:30.52,Default,,0,0,0,,当然 我们要假定创始区块初始化了一个随机种子
Dialogue: 0,0:22:30.52,0:22:37.98,Default,,0,0,0,,现在 假定我们有一个神奇的锚点 当区块链生成到给定的锚点时
Dialogue: 0,0:22:37.98,0:22:45.58,Default,,0,0,0,,我们可以得到一个新的种子 从而重新根据权益拥有者的权益分布生成新的记账顺序
Dialogue: 0,0:22:45.58,0:22:51.02,Default,,0,0,0,,到达锚点后 锚点会给我们另一个种子 我们用这个种子重新分配记账顺序
Dialogue: 0,0:22:51.02,0:22:57.16,Default,,0,0,0,,我们需要利用区块链自身的特性来更新权益拥有者的记账概率分布
Dialogue: 0,0:22:57.16,0:23:06.58,Default,,0,0,0,,而新的记账概率分布由一系列交易执行过程后 各个参与方的新权益量所决定
Dialogue: 0,0:23:06.58,0:23:18.92,Default,,0,0,0,,也就是说 我们根据区块链的一部分记录结果 应用锚点重新生成种子
Dialogue: 0,0:23:18.92,0:23:24.48,Default,,0,0,0,,然后再用新的种子创建更新后的权益拥有者记账概率分布
Dialogue: 0,0:23:24.48,0:23:26.94,Default,,0,0,0,,协议继续执行下去
Dialogue: 0,0:23:26.94,0:23:32.80,Default,,0,0,0,,当然了 在现实生活中我们没有这样一个可信锚点
Dialogue: 0,0:23:32.80,0:23:34.76,Default,,0,0,0,,这么解决这个问题呢？
Dialogue: 0,0:23:34.76,0:23:41.52,Default,,0,0,0,,答案是利用G.O.D 即保证“产出交付的硬币投掷”
Dialogue: 0,0:23:41.52,0:23:48.92,Default,,0,0,0,,“保证产出交付的硬币投掷” 或称G.O.D硬币投掷 可以确保输出的随机性
Dialogue: 0,0:23:48.92,0:23:55.30,Default,,0,0,0,,其基本意思是 如果协议的大多数执行方都是诚实的 则保证输出结果是无偏随机种子
Dialogue: 0,0:23:55.30,0:24:02.70,Default,,0,0,0,,我们要做的是要执行一小段时间的基础协议 产生一部分区块片段
Dialogue: 0,0:24:02.70,0:24:13.16,Default,,0,0,0,,这样我们就可以执行G.O.D硬币投掷协议 从而为下一个纪元产出一个随机种子
Dialogue: 0,0:24:13.16,0:24:18.16,Default,,0,0,0,,整个协议执行过程需要应用一个称为公开可验证密钥协商协议的工具
Dialogue: 0,0:24:18.16,0:24:24.06,Default,,0,0,0,,而我们可以通过简单的密码学工具构建公开可验证密钥协商协议
Dialogue: 0,0:24:24.06,0:24:28.32,Default,,0,0,0,,应用上述提到的所有工具和协议 我们最终证明账本可以达到目标
Dialogue: 0,0:24:28.32,0:24:33.32,Default,,0,0,0,,虽然我没有时间讲解整个证明的细节 但我们可以通过理论证明
Dialogue: 0,0:24:33.32,0:24:38.88,Default,,0,0,0,,假定攻击者具有一定程度的适应性攻击能力
Dialogue: 0,0:24:38.88,0:24:46.14,Default,,0,0,0,,则Ouroboros协议的公共前缀、链质量、链生长速度等的错误率都是k的可忽略函数
Dialogue: 0,0:24:46.14,0:24:50.66,Default,,0,0,0,,这意味着可以用Ouroboros实现一个健壮的交易账本
Dialogue: 0,0:24:50.66,0:24:56.06,Default,,0,0,0,,我在本次讲座中没时间讲解论文的全部内容了 各位可以在论文中发现一些其它成果
Dialogue: 0,0:24:56.06,0:25:01.70,Default,,0,0,0,,除了上述协议之外 我们还设计出了一个基于权重的激励模型
Dialogue: 0,0:25:01.70,0:25:04.22,Default,,0,0,0,,我这里跳过这几页幻灯片
Dialogue: 0,0:25:04.22,0:25:06.92,Default,,0,0,0,,我们直接来看最后的结论吧
Dialogue: 0,0:25:06.92,0:25:15.52,Default,,0,0,0,,我们证明 在Ouroboros协议上执行所设计的激励奖励机制可达到近似纳什均衡
Dialogue: 0,0:25:15.52,0:25:24.62,Default,,0,0,0,,而且与比特币相比 我们的激励机制与协议是完全兼容的
Dialogue: 0,0:25:24.62,0:25:32.82,Default,,0,0,0,,进一步 我们设计实验测试了协议的性能 具体结论在这页幻灯片上
Dialogue: 0,0:25:32.82,0:25:36.74,Default,,0,0,0,,我们在亚马逊云上用40个节点运行了实验
Dialogue: 0,0:25:36.74,0:25:38.82,Default,,0,0,0,,我们实现了协议 并测试了协议的性能
Dialogue: 0,0:25:38.82,0:25:43.66,Default,,0,0,0,,大家可以看到 权益证明协议可以达到良好的性能
Dialogue: 0,0:25:43.66,0:25:49.68,Default,,0,0,0,,在这种简单的协议实现下 每秒确认的交易数量可以达到250个
Dialogue: 0,0:25:49.68,0:25:56.18,Default,,0,0,0,,大家可以把这个结果和每秒确认7、8、或者9个的比特币协议进行对比
Dialogue: 0,0:25:56.18,0:26:01.98,Default,,0,0,0,,后续工作中 我们将解决本工作尚没有解决的问题
Dialogue: 0,0:26:01.98,0:26:08.84,Default,,0,0,0,,后续工作将解决半异步、或者部分同步网络 攻击者合谋条件下的协议设计问题
Dialogue: 0,0:26:08.84,0:26:12.34,Default,,0,0,0,,这个工作是我和Bernardo David、Peter Gazi和Alexander Russell一起完成的
Dialogue: 0,0:26:12.34,0:26:15.90,Default,,0,0,0,,大家可以在ePrint上读到此篇论文
Dialogue: 0,0:26:15.90,0:26:21.26,Default,,0,0,0,,这些也是后续工作 大家在网上可以找到演讲视频
Dialogue: 0,0:26:21.26,0:26:30.08,Default,,0,0,0,,讲座时间快到了 这些是相关工作 大家可以在ePrint版本或会议版本找到相关文献
Dialogue: 0,0:26:30.08,0:26:31.44,Default,,0,0,0,,这就是幻灯片的最后一页了
Dialogue: 0,0:26:31.44,0:26:33.32,Default,,0,0,0,,感谢大家前来聆听讲座
Dialogue: 0,0:26:36.94,0:26:41.94,Default,,0,0,0,,{\pos(958.5,74.999)}听译、时间轴：刘巍然（学酥）
