[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Audio File: Improved OT Extension for Transferring Short Secrets.mp4
Video File: Improved OT Extension for Transferring Short Secrets.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 85
Active Line: 102
Video Position: 28916

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,45,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.90,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:04.98,0:00:07.24,Default,,0,0,0,,非常感谢主持人的介绍
Dialogue: 0,0:00:07.98,0:00:11.10,Default,,0,0,0,,此工作是我与来自贝尔实验室的Vladimir Kalashnikov所共同完成的
Dialogue: 0,0:00:18.70,0:00:24.09,Default,,0,0,0,,我们工作针对的目标是安全计算 这是密码学上一个非常典型、非常普遍的问题
Dialogue: 0,0:00:25.00,0:00:32.25,Default,,0,0,0,,当前有很多重要的研究进展 尝试让安全计算从理论走向实际
Dialogue: 0,0:00:32.25,0:00:37.66,Default,,0,0,0,,这些工作的目标不仅是要提高协议的渐进效率 还要提高协议的真实执行效率
Dialogue: 0,0:00:37.66,0:00:41.98,Default,,0,0,0,,还有一些工作的方向是具体协议的实现 解决系统层面的问题
Dialogue: 0,0:00:42.59,0:00:48.43,Default,,0,0,0,,在过去的5年 无论是理论角度还是实际角度 此领域都诞生了极多的突破性成果
Dialogue: 0,0:00:48.43,0:00:51.16,Default,,0,0,0,,从理论角度 我们得到了很多惊人的结论
Dialogue: 0,0:00:51.16,0:00:56.75,Default,,0,0,0,,我们现在只需要引入常数级额外开销 即可完成安全计算或安全函数求值
Dialogue: 0,0:00:56.75,0:01:00.04,Default,,0,0,0,,另一个突破是全同态加密
Dialogue: 0,0:01:00.64,0:01:06.75,Default,,0,0,0,,对于多种类型的函数 我们甚至可以在最优通信复杂度下构建安全计算协议
Dialogue: 0,0:01:06.75,0:01:14.70,Default,,0,0,0,,还可以使用基于ORAM的安全计算协议 利用RAM计算模型的优势完成安全计算
Dialogue: 0,0:01:14.70,0:01:19.18,Default,,0,0,0,,这样我们就能在次线性时间复杂度下完成安全计算
Dialogue: 0,0:01:19.18,0:01:28.49,Default,,0,0,0,,在实践角度 针对姚氏协议和GMW协议 学者们提出了很多算法或实现层面的优化
Dialogue: 0,0:01:28.49,0:01:31.77,Default,,0,0,0,,也尝试混合使用姚氏协议和GMW协议
Dialogue: 0,0:01:31.77,0:01:39.16,Default,,0,0,0,,特别地 姚氏协议的实现结果令人印象深刻
Dialogue: 0,0:01:39.16,0:01:43.16,Default,,0,0,0,,现在 我们可以在637毫秒内执行完AES的乱码电路
Dialogue: 0,0:01:44.40,0:01:52.56,Default,,0,0,0,,虽然在实现层面和理论层面 我们都得到了令人惊讶的成果
Dialogue: 0,0:01:52.56,0:02:00.73,Default,,0,0,0,,但在右侧 效率最高的协议仍然是20世纪80年代提出的姚氏协议和GMW协议
Dialogue: 0,0:02:00.73,0:02:03.12,Default,,0,0,0,,之所以这样 有一个很直观的原因
Dialogue: 0,0:02:03.12,0:02:08.20,Default,,0,0,0,,理论成果虽然引入常数复杂度 但这个常数可能非常大
Dialogue: 0,0:02:08.20,0:02:11.63,Default,,0,0,0,,实际应用时 可能存在这样一个复杂度与效率的层级关系
Dialogue: 0,0:02:11.63,0:02:20.12,Default,,0,0,0,,FHE的复杂度目前、以后也总会比公钥密码学原语的复杂度高几个量级
Dialogue: 0,0:02:20.12,0:02:27.42,Default,,0,0,0,,公钥密码学原语的复杂度目前、以后也总会比对称密码学原语的复杂度高几个量级
Dialogue: 0,0:02:27.42,0:02:35.13,Default,,0,0,0,,对称密码学原语的复杂度目前、以后也总会比一次一密的复杂度高几个量级
Dialogue: 0,0:02:35.13,0:02:41.98,Default,,0,0,0,,本次演讲的主题是OT扩展 其出发点就是减小公钥操作和对称密码操作的效率鸿沟
Dialogue: 0,0:02:43.16,0:02:52.16,Default,,0,0,0,,在第一部分演讲中 我会详细介绍OT扩展的研究出发点 并解释OT扩展面临的问题
Dialogue: 0,0:02:52.16,0:02:57.98,Default,,0,0,0,,诸如密钥协商、不经意传输等公钥密码学原语一般都很难高效实现
Dialogue: 0,0:02:57.98,0:03:04.06,Default,,0,0,0,,公钥密码学原语天生要依赖于某类代数结构 因此也会遭受很多密码学攻击
Dialogue: 0,0:03:04.06,0:03:06.06,Default,,0,0,0,,因此 相应的参数需要设置得比较大
Dialogue: 0,0:03:06.06,0:03:08.33,Default,,0,0,0,,这导致公钥密码学的计算复杂度也相对较高
Dialogue: 0,0:03:08.33,0:03:14.57,Default,,0,0,0,,另一方面 我们更容易实现伪随机数生成器或哈希函数等对称密码学运算
Dialogue: 0,0:03:14.57,0:03:15.84,Default,,0,0,0,,学者们设计出了很多算法
Dialogue: 0,0:03:15.84,0:03:17.53,Default,,0,0,0,,相应的参数要比公钥密码学小得多
Dialogue: 0,0:03:17.53,0:03:19.74,Default,,0,0,0,,实际中也可以更容易、更轻量级地实现对称密码学运算
Dialogue: 0,0:03:19.74,0:03:21.39,Default,,0,0,0,,这个结论背后还有相应的理论支撑
Dialogue: 0,0:03:21.39,0:03:26.46,Default,,0,0,0,,理论上 无法通过黑盒方式应用对称密码学原语构造大多数公钥密码学原语
Dialogue: 0,0:03:26.46,0:03:35.19,Default,,0,0,0,,这意味着公钥密码学原语和对称密码学原语的性能差约为3至4个数量级
Dialogue: 0,0:03:35.19,0:03:41.12,Default,,0,0,0,,对于诸如AES等被广泛使用的特定对称密码学操作
Dialogue: 0,0:03:41.12,0:03:45.53,Default,,0,0,0,,Intel专门提供了对应的指令集 进一步提高了这类运算的执行效率
Dialogue: 0,0:03:46.83,0:03:51.76,Default,,0,0,0,,因此 我们无法通过对称密码学原语实现公钥密码学原语 那接下来该怎么办？
Dialogue: 0,0:03:51.76,0:04:01.28,Default,,0,0,0,,或许可以用少量公钥原语实例和大量对称密码学操作 生成大量公钥实例
Dialogue: 0,0:04:01.28,0:04:03.66,Default,,0,0,0,,这一技术称为“扩展原语”
Dialogue: 0,0:04:03.66,0:04:07.26,Default,,0,0,0,,我们已经知道 很容易扩展公钥加密体制
Dialogue: 0,0:04:07.26,0:04:13.82,Default,,0,0,0,,具体过程是用对称加密算法加密具体的明文 用公钥加密算法加密对称加密的密钥
Dialogue: 0,0:04:13.82,0:04:15.98,Default,,0,0,0,,这样一来 我们只需要执行一次公钥操作
Dialogue: 0,0:04:15.98,0:04:20.24,Default,,0,0,0,,这一技术在我们每天使用的加密过程中起到了非常重要的作用
Dialogue: 0,0:04:20.24,0:04:27.45,Default,,0,0,0,,我们可以很自然地把这个问题展开 是否可以扩展其它公钥密码学原语 如OT？
Dialogue: 0,0:04:27.45,0:04:34.19,Default,,0,0,0,,回忆一下不经意传输要解决的问题 发送方有两个输入x_0和x_1 接收方有一个输入r
Dialogue: 0,0:04:34.19,0:04:37.39,Default,,0,0,0,,协议执行完毕后 发送方无法得到任何信息
Dialogue: 0,0:04:37.39,0:04:42.25,Default,,0,0,0,,接收方可以得到与其选择比特关联的发送方输入
Dialogue: 0,0:04:42.25,0:04:45.26,Default,,0,0,0,,OT是SFE的基础构建模块
Dialogue: 0,0:04:45.26,0:04:49.32,Default,,0,0,0,,姚氏电路中应用不经意传输实现了乱码密钥的2选1过程
Dialogue: 0,0:04:49.32,0:04:54.54,Default,,0,0,0,,在GMW协议中 OT的用途更加广泛 每个AND门的求值过程都要使用一次OT协议
Dialogue: 0,0:04:55.85,0:04:59.21,Default,,0,0,0,,我们知道OT的执行开销非常大
Dialogue: 0,0:04:59.21,0:05:01.45,Default,,0,0,0,,我们无法通过对称密码学操作实现OT
Dialogue: 0,0:05:01.45,0:05:04.16,Default,,0,0,0,,但假设我们有一个可以传输短字符串的OT
Dialogue: 0,0:05:04.16,0:05:08.59,Default,,0,0,0,,通过使用标准的伪随机数生成器 我们能得到可以传输长字符串的OT
Dialogue: 0,0:05:08.59,0:05:10.72,Default,,0,0,0,,这一技术称为“OT长度扩展”
Dialogue: 0,0:05:11.50,0:05:16.44,Default,,0,0,0,,还有一个更难解决的问题 称为“OT实例扩展” 简称“OT扩展”
Dialogue: 0,0:05:16.44,0:05:18.43,Default,,0,0,0,,幸运的是 我们知道OT扩展是可行的
Dialogue: 0,0:05:18.43,0:05:24.20,Default,,0,0,0,,我们只需要k个公钥密码学操作 即k个种子OT 再加上n次对称密码学操作
Dialogue: 0,0:05:24.20,0:05:33.69,Default,,0,0,0,,应用这k次公钥密码学操作 我们就可以执行任意多项式大小次的OT操作
Dialogue: 0,0:05:33.69,0:05:41.52,Default,,0,0,0,,这一技术大幅降低了公钥密码学运算次数 对SFE的实际应用起到了重要的作用
Dialogue: 0,0:05:41.52,0:05:45.66,Default,,0,0,0,,近期大多数SFE的实现都应用了OT扩展协议 从而提高协议的执行效率
Dialogue: 0,0:05:46.89,0:05:50.16,Default,,0,0,0,,Beaver在1996年提出了第一个OT扩展协议
Dialogue: 0,0:05:50.16,0:05:54.40,Default,,0,0,0,,第一个高效的OT扩展协议由Ishai、Kilian、Nissim和Petrank给出
Dialogue: 0,0:05:54.40,0:05:56.16,Default,,0,0,0,,此协议也称为IKNP协议
Dialogue: 0,0:05:56.16,0:05:58.62,Default,,0,0,0,,对应的论文发表在CRYPTO 2003上
Dialogue: 0,0:05:59.58,0:06:04.62,Default,,0,0,0,,后续 学者们期望在恶意攻击场景下提高OT扩展协议的执行效率
Dialogue: 0,0:06:04.62,0:06:10.35,Default,,0,0,0,,学者们同时也在加深对OT扩展协议的理解 从而知道OT扩展协议的上限是什么
Dialogue: 0,0:06:10.35,0:06:14.75,Default,,0,0,0,,在本工作中 我们将在半可信场景下提高IKNP协议的效率
Dialogue: 0,0:06:14.75,0:06:18.09,Default,,0,0,0,,我们给出了协议的渐进优化方法和实际优化方法
Dialogue: 0,0:06:19.61,0:06:26.78,Default,,0,0,0,,在接下来的讲座中 我们会描述Ishai等人的OT扩展协议构造
Dialogue: 0,0:06:26.78,0:06:30.76,Default,,0,0,0,,实际上 我们将直接使用Ishai等人CRYPTO 2003的演讲幻灯片
Dialogue: 0,0:06:31.55,0:06:40.88,Default,,0,0,0,,IKNP第一个、也是最重要的步骤是将n个OT归约为传输n比特字符串的k个OT
Dialogue: 0,0:06:40.88,0:06:45.79,Default,,0,0,0,,这一步骤将引入额外的、线性数量级的对称密码学操作
Dialogue: 0,0:06:45.79,0:06:49.56,Default,,0,0,0,,下一步是长度扩展步骤 我们之前已经讲解过这一步骤了
Dialogue: 0,0:06:49.56,0:06:53.74,Default,,0,0,0,,这可以让我们把长字符串OT协议归约为短字符串OT协议
Dialogue: 0,0:06:53.74,0:07:00.62,Default,,0,0,0,,这一步骤进一步引入了线性数量级的对称密码学操作
Dialogue: 0,0:07:00.62,0:07:08.12,Default,,0,0,0,,在核心归约步骤中 我们让接收方选择一个随机的n×k矩阵T
Dialogue: 0,0:07:08.12,0:07:12.19,Default,,0,0,0,,随后 发送方选择一个随机的行向量s
Dialogue: 0,0:07:12.19,0:07:18.17,Default,,0,0,0,,接下来 接收方和发送方执行k个OT协议 但此OT协议中两个参与方的角色互换
Dialogue: 0,0:07:18.17,0:07:24.06,Default,,0,0,0,,在每个OT协议中 接收方要选择长度为n的两列比特值
Dialogue: 0,0:07:24.06,0:07:29.24,Default,,0,0,0,,每对比特值中 第一列为矩阵T中的某一列
Dialogue: 0,0:07:29.24,0:07:36.01,Default,,0,0,0,,第二列为第一列比特值与选择向量r的异或结果
Dialogue: 0,0:07:36.01,0:07:44.72,Default,,0,0,0,,发送方实际上应用它随机选择的行向量在接收方的两列比特值中选择一列
Dialogue: 0,0:07:45.74,0:07:50.45,Default,,0,0,0,,这样 发送方通过OT协议得到了一个矩阵Q
Dialogue: 0,0:07:50.45,0:07:54.04,Default,,0,0,0,,我们来看看矩阵Q满足何种性质
Dialogue: 0,0:07:54.04,0:07:57.56,Default,,0,0,0,,如果r_i=0 则q_i=t_i
Dialogue: 0,0:07:58.32,0:08:03.61,Default,,0,0,0,,如果r_i=1 收到的每对比特值就不太一样了
Dialogue: 0,0:08:03.61,0:08:07.56,Default,,0,0,0,,如果r_i=1 在IKNP协议中q_i=t_i⊕s
Dialogue: 0,0:08:07.56,0:08:11.95,Default,,0,0,0,,注意到在第一种情况下 接收方知道t_i 但无法知道t_i⊕s
Dialogue: 0,0:08:11.95,0:08:14.83,Default,,0,0,0,,因此 在第一种情况下 接收方能得到q_i 但无法得到q_i⊕s
Dialogue: 0,0:08:14.83,0:08:20.48,Default,,0,0,0,,在第二种情况下 接收方能得到q_i⊕s 也就是t_i 但无法得到q_i
Dialogue: 0,0:08:20.48,0:08:25.48,Default,,0,0,0,,这意味着我们或许可以使用q_i和q_i⊕s作为OT协议中的数据加密密钥
Dialogue: 0,0:08:26.24,0:08:33.16,Default,,0,0,0,,但需要注意的是 我们必须要破坏矩阵中q_i和q_i⊕s的相互关系
Dialogue: 0,0:08:33.16,0:08:37.60,Default,,0,0,0,,我们应用随机预言机H来破坏q_i和q_i⊕s的相互关系
Dialogue: 0,0:08:37.60,0:08:42.28,Default,,0,0,0,,最后 接收方根据t_i选择得到它的输出 也就是应用t_i进行解密
Dialogue: 0,0:08:43.93,0:08:48.20,Default,,0,0,0,,IKNP协议非常简单、非常优雅、效率极高
Dialogue: 0,0:08:48.20,0:08:55.76,Default,,0,0,0,,我们考虑n个OT协议所需要的通信开销 其中发送方输入的长度为L
Dialogue: 0,0:08:55.76,0:09:01.20,Default,,0,0,0,,大家已经了解到 核心归约步骤就是对x_(i,0)和x_(i,1)加密
Dialogue: 0,0:09:01.20,0:09:03.21,Default,,0,0,0,,这需要发送2nL比特的数据
Dialogue: 0,0:09:03.21,0:09:06.92,Default,,0,0,0,,在长度扩展步骤中 我们要应用一个PRG 这需要发送2nk比特的数据
Dialogue: 0,0:09:06.92,0:09:11.13,Default,,0,0,0,,在姚氏电路中 我们需要传输长度为L=k的密钥
Dialogue: 0,0:09:11.13,0:09:15.72,Default,,0,0,0,,因此核心归约步骤和长度扩展步骤中的通信开销相同
Dialogue: 0,0:09:15.72,0:09:19.42,Default,,0,0,0,,在GMW中 我们只需要传输L=1的信息
Dialogue: 0,0:09:19.42,0:09:25.34,Default,,0,0,0,,令人惊讶的是 这一场景下长度扩展步骤的通信开销远高于核心归约步骤的通信开销
Dialogue: 0,0:09:25.34,0:09:29.56,Default,,0,0,0,,这就是一个问题了 我们可能可以在这一场景下对通信开销进行优化
Dialogue: 0,0:09:29.56,0:09:35.55,Default,,0,0,0,,在讲座的后半部分 我们会提出IKNP的通用框架
Dialogue: 0,0:09:35.55,0:09:40.32,Default,,0,0,0,,我们也会向大家展示如何提高IKNP的效率
Dialogue: 0,0:09:41.69,0:09:44.96,Default,,0,0,0,,我们先来详细分析一下IKNP协议
Dialogue: 0,0:09:44.96,0:09:50.19,Default,,0,0,0,,可以看到 接收方要选择这个n×k的随机矩阵
Dialogue: 0,0:09:50.19,0:09:53.66,Default,,0,0,0,,随后 接收方要生成另一个矩阵
Dialogue: 0,0:09:53.66,0:09:59.63,Default,,0,0,0,,这个矩阵的第i列为第一个矩阵的第i列异或选择向量r
Dialogue: 0,0:09:59.63,0:10:11.52,Default,,0,0,0,,换句话说 U= T⊕R 其中R是所有列均相等的矩阵 每个列都为接收方的选择向量
Dialogue: 0,0:10:12.68,0:10:26.20,Default,,0,0,0,,如果我们从行的视角看 就会发现R的第i行为k个r_i
Dialogue: 0,0:10:26.20,0:10:28.84,Default,,0,0,0,,这意味着R的每一行都是r_i的一种编码
Dialogue: 0,0:10:28.84,0:10:32.60,Default,,0,0,0,,在IKNP协议中 0被映射为0^k 而1被映射为1^k
Dialogue: 0,0:10:32.60,0:10:39.02,Default,,0,0,0,,因此 我们可以看到IKNP这一高效协议在底层执行了一次逐行重复编码
Dialogue: 0,0:10:39.02,0:10:42.60,Default,,0,0,0,,这自然引出了一个问题：我们是否可以使用更复杂的编码？
Dialogue: 0,0:10:42.60,0:10:46.22,Default,,0,0,0,,毕竟 重复编码是一种最简单的编码
Dialogue: 0,0:10:47.52,0:10:53.10,Default,,0,0,0,,假设我们使用编码C 并且我们假定r_i属于一个很大的域 域为从1到m
Dialogue: 0,0:10:53.10,0:10:57.92,Default,,0,0,0,,我们用编码C将r_i映射成C(r_i) 这是一个k比特长字符串
Dialogue: 0,0:10:57.92,0:11:06.41,Default,,0,0,0,,现在 接收方需要用选择比特r_i构建矩阵C(R)
Dialogue: 0,0:11:06.41,0:11:10.27,Default,,0,0,0,,我们来看看 在这个理论框架下IKNP协议的执行过程
Dialogue: 0,0:11:10.27,0:11:13.77,Default,,0,0,0,,第一步 接收方获得了矩阵C(R)
Dialogue: 0,0:11:13.77,0:11:17.92,Default,,0,0,0,,随后 接收方用加法秘密分享方案将C(R)分享为T和U 即C(R)= T⊕U
Dialogue: 0,0:11:17.92,0:11:22.76,Default,,0,0,0,,接下来 接收方和发送方角色互换 执行k个OT协议
Dialogue: 0,0:11:22.76,0:11:30.67,Default,,0,0,0,,在第i个OT中 接收方的输入是t^i和u^i 即T和U的第i列
Dialogue: 0,0:11:30.67,0:11:37.02,Default,,0,0,0,,执行完OT协议后 发送方得到矩阵Q
Dialogue: 0,0:11:37.02,0:11:42.17,Default,,0,0,0,,在IKNP协议中 我们知道q_i或者等于t_i 或者等于t_i⊕s
Dialogue: 0,0:11:42.17,0:11:49.47,Default,,0,0,0,,在这一理论框架中 我们可以知道q_i=t_i⊕(C(r_i)⊙s)
Dialogue: 0,0:11:49.47,0:11:52.19,Default,,0,0,0,,结果不算太复杂
Dialogue: 0,0:11:52.19,0:11:58.81,Default,,0,0,0,,我们可以验证一下 当C是重复编码时 此框架对应的协议就是IKNP协议
Dialogue: 0,0:11:58.81,0:12:05.24,Default,,0,0,0,,特别地 当r_i=0时 C(r_i)是一个全0向量 因此我们得到q_i=t_i
Dialogue: 0,0:12:05.24,0:12:13.92,Default,,0,0,0,,当r_i=1时 C(r_i)是一个全1向量 此时我们可以得到q_i=t_i⊕s
Dialogue: 0,0:12:13.92,0:12:19.80,Default,,0,0,0,,这样一来 我们得到了m个密钥 后面的执行过程就完全一样了
Dialogue: 0,0:12:19.80,0:12:23.13,Default,,0,0,0,,密钥生成算法为q_i⊕(C(r)⊙s)
Dialogue: 0,0:12:23.13,0:12:27.50,Default,,0,0,0,,我们仍然可以证明接收方只能知道t_i
Dialogue: 0,0:12:27.50,0:12:34.75,Default,,0,0,0,,因此 接收方只能解密对应的密文 从而得到对应的输入
Dialogue: 0,0:12:34.75,0:12:41.84,Default,,0,0,0,,核心归约步骤在恶意发送方的攻击下是完美安全的
Dialogue: 0,0:12:42.80,0:12:49.20,Default,,0,0,0,,特别地 恶意发送方只能得到矩阵Q 这是编码的随机独立分享结果
Dialogue: 0,0:12:49.20,0:12:53.16,Default,,0,0,0,,核心归约步骤在半诚实接收方的攻击下是统计安全的
Dialogue: 0,0:12:53.16,0:13:00.28,Default,,0,0,0,,这是因为除了在加密过程中使用了随机预言机之外 核心归约步骤没有安全性损失
Dialogue: 0,0:13:00.28,0:13:03.77,Default,,0,0,0,,因此 整个协议的安全性损失为m 即r_i的取值范围
Dialogue: 0,0:13:03.77,0:13:11.10,Default,,0,0,0,,以及2^(-d) 其中d是线性编码C的最小距离
Dialogue: 0,0:13:12.64,0:13:17.20,Default,,0,0,0,,注意到在此理论框架下 我们可以从1到m选取消息
Dialogue: 0,0:13:17.20,0:13:22.86,Default,,0,0,0,,因此从效果上看 我们可以实现m选1-OT 而不是2选1-OT
Dialogue: 0,0:13:23.74,0:13:31.23,Default,,0,0,0,,但在这种情况下 核心归约步骤的通信开销会从2nL提高到nmL
Dialogue: 0,0:13:31.23,0:13:44.44,Default,,0,0,0,,随后 我们将标准的2选1-OT转换为n/log(m)个字符串长度稍长的m选1-OT实例
Dialogue: 0,0:13:44.44,0:13:49.04,Default,,0,0,0,,这也允许我们将通信开销表示为与m相关的函数
Dialogue: 0,0:13:49.04,0:13:55.64,Default,,0,0,0,,现在 我们有了一个自由变量m 用它来平衡核心归约步骤和长度扩展步骤的开销
Dialogue: 0,0:13:55.64,0:14:03.37,Default,,0,0,0,,具体来说 如果我们使用的是最小距离为k/2的Hadamard编码
Dialogue: 0,0:14:03.37,0:14:09.66,Default,,0,0,0,,在这种情况下 2选1-OT的通信开销可以降低2倍
Dialogue: 0,0:14:09.66,0:14:17.21,Default,,0,0,0,,在多方GMW协议中 如果k=256 则通信开销也可以降低2倍
Dialogue: 0,0:14:17.21,0:14:22.41,Default,,0,0,0,,也可以进一步优化长度扩展步骤的通信开销 优化程度为…
Dialogue: 0,0:14:22.41,0:14:26.97,Default,,0,0,0,,通信开销优化程度是算法层面的 而不是渐进层面的 相应的优化程度为…
Dialogue: 0,0:14:26.97,0:14:36.86,Default,,0,0,0,,结合Hadamard编码后 与未优化的IKNP协议相比 新协议的通信开销要降低3.5倍
Dialogue: 0,0:14:36.86,0:14:42.81,Default,,0,0,0,,Asharov等人也独立发现了这一优化点 他们的论文将发表在CCS 2013上
Dialogue: 0,0:14:42.81,0:14:47.47,Default,,0,0,0,,与IKNP相比 我们从渐进层面降低了每一个OT的通信开销
Dialogue: 0,0:14:47.47,0:14:53.45,Default,,0,0,0,,当L=1时 IKNP需要通信O(k)比特 而我们需要通信O(k/log(k))比特
Dialogue: 0,0:14:55.23,0:14:56.70,Default,,0,0,0,,总结一下
Dialogue: 0,0:14:57.18,0:15:05.26,Default,,0,0,0,,为了平衡公钥密码学原语和对称密码学原语的性能鸿沟 学者们提出了OT扩展协议
Dialogue: 0,0:15:05.26,0:15:11.31,Default,,0,0,0,,这一协议在安全函数求值的实例落地中产生了巨大的影响
Dialogue: 0,0:15:11.31,0:15:15.05,Default,,0,0,0,,在本次讲座中 我们提出了IKNP的编码理论框架
Dialogue: 0,0:15:15.61,0:15:18.54,Default,,0,0,0,,可以在随机预言模型下证明此框架的安全性
Dialogue: 0,0:15:18.54,0:15:23.53,Default,,0,0,0,,随机预言模型也可以换为特定类型哈希函数假设 即相关性健壮哈希函数
Dialogue: 0,0:15:23.53,0:15:27.53,Default,,0,0,0,,这沿用了IKNP中安全性所依赖的相关性健壮哈希函数假设
Dialogue: 0,0:15:27.53,0:15:37.68,Default,,0,0,0,,当使用复杂编码时 此框架提高了多方GMW中2选1-OT和m选1-OT的性能
Dialogue: 0,0:15:38.32,0:15:44.96,Default,,0,0,0,,我想用GMW和姚氏电路的性能对比问题作为讲座的结尾
Dialogue: 0,0:15:44.96,0:15:51.28,Default,,0,0,0,,近期的安全多方计算研究主要关注恶意模型下姚氏电路的性能优化问题
Dialogue: 0,0:15:51.28,0:15:55.52,Default,,0,0,0,,在半可信安全模型下 学者们也提出了很多姚氏电路的优化方法
Dialogue: 0,0:15:55.52,0:16:01.36,Default,,0,0,0,,但近期的一些工作也表明 GMW协议也有很多算法层面的优化点
Dialogue: 0,0:16:01.36,0:16:04.83,Default,,0,0,0,,我们的工作适用于GMW协议
Dialogue: 0,0:16:04.83,0:16:05.94,Default,,0,0,0,,谢谢大家
Dialogue: 0,0:16:03.86,0:16:08.86,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
